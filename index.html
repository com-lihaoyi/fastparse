<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>FastParse 0.3.6</title><script src="scripts.js"></script></head><body><div>

<a href="https://github.com/lihaoyi/fastparse" style="position: absolute;top: 0px;right: 0px;border: 0;"><img src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>


<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FastParse0.3.6" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FastParse 0.3.6<a class=" scalatex-site-Styles-headerLink" href="#FastParse0.3.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /><h2 style="font-weight: 300;color: #ccc;padding: 0px;margin-top: 0px;">Fast to write, Fast running Parsers in Scala</h2></div><div class=" scalatex-site-Styles-content">
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)
val expr: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L18-L26" target="_blank"><i class="fa fa-link "></i></a></pre>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">check(&quot;1+1&quot;, 2)
check(&quot;1+1*2&quot;, 3)
check(&quot;(1+1*2)+(3*4*5)&quot;, 63)
check(&quot;15/3&quot;, 5)
check(&quot;63/3&quot;, 21)
check(&quot;(1+1*2)+(3*4*5)/20&quot;, 6)
check(&quot;((1+1*2)+(3*4*5))/3&quot;, 21)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L33-L40" target="_blank"><i class="fa fa-link "></i></a></pre>
    <div id="splashdiv"></div>
    <script>demo.DemoMain().math(document.getElementById("splashdiv"))</script>
    <p>
        FastParse is a parser-combinator library for Scala that lets you quickly and easily write recursive descent parsers in Scala. Features include:
</p>
    <ul>
        <li>
            Up to 1/5 the speed of a hand-written parser, 100x faster than <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a>, comparable (though slightly slower than) <a href="https://github.com/sirthias/parboiled2">Parboiled2</a></li>
        <li>
            1/10th the size of a hand-written parser</li>
        <li>
            Automatic, excellent error-reporting and diagnostics.</li>
        <li>
            Zero allocations during a parse</li>
        <li>
            Compatible with both Scala-JVM and Scala.js</li></ul>
    <p>
         The following sections will introduce you to FastParse and how to use it. You can also watch this talk:</p>
    <iframe src="https://player.vimeo.com/video/142341803" width="800" height="450" style="margin-left: auto;margin-right: auto;display: block;" frameborder="0" webkitallowfullscreen="1" mozallowfullscreen="1" allowfullscreen="1"></iframe>
    <p>
        Which will give you a quick 1-hour tour of how to use FastParse, the motivation behind the library, and how it fits into the bigger picture of how programmers parse unstructured text.
</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="GettingStarted" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Getting Started<a class=" scalatex-site-Styles-headerLink" href="#GettingStarted" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            To begin using FastParse, add
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;fastparse&quot; % &quot;0.3.6&quot;
</code></pre>
        <p>
            To your SBT configuration. To use with Scala.js, you'll need</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;fastparse&quot; % &quot;0.3.6&quot;


</code></pre>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="WritingParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Writing Parsers<a class=" scalatex-site-Styles-headerLink" href="#WritingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <h1 id="Basic" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Basic" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Basic</h1>
            <p>
                The simplest parser matches a single string:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.all._
val parseA = P( &quot;a&quot; )

val Parsed.Success(value, successIndex) = parseA.parse(&quot;a&quot;)
assert(value == (), successIndex == 1)

val failure = parseA.parse(&quot;b&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.lastParser == (&quot;a&quot;: P0),
  failure.index == 0,
  failure.extra.traced.trace == &quot;&quot;&quot;parseA:1:1 / &quot;a&quot;:1:1 ...&quot;b&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L14-L26" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Such a parser returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> if the input matches the string, and otherwise returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code>.</p>
            <p>
                As you can see, by default the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> contains a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(): Unit</code>, unless you use <a href="#Capture">Capture</a> or <a href="#Map">Map</a> described below. Also, apart from the structured data of the failure, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code> also contains a nice human-readable trace of the parse showing the stack of parsers which were in progress when the parse failed. The trace can be obtained via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure.Extra.trace</code>.
</p>
            <p>
                You can also wrap the strings in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase(&quot;...&quot;)</code> if you want the matching to be case-insensitive.
</p>
            <h2 id="Sequence" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Sequence" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Sequence</h2>

                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;a&quot; ~ &quot;b&quot; )

val Parsed.Success(_, 2) = ab.parse(&quot;ab&quot;)

val Parsed.Failure(parser, 1, _) = ab.parse(&quot;aa&quot;)
assert(parser == (&quot;b&quot;: P0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L29-L35" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    You can combine two parsers with the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code> operator. This creates a new parser that only succeeds if both left and right parsers succeed one after another.
</p>
            <h2 id="Repeat" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Repeat" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Repeat</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;a&quot;.rep ~ &quot;b&quot; )
val Parsed.Success(_, 8) = ab.parse(&quot;aaaaaaab&quot;)
val Parsed.Success(_, 4) = ab.parse(&quot;aaaba&quot;)

val abc = P( &quot;a&quot;.rep(sep=&quot;b&quot;) ~ &quot;c&quot;)
val Parsed.Success(_, 8) = abc.parse(&quot;abababac&quot;)
val Parsed.Failure(parser, 3, _) = abc.parse(&quot;abaabac&quot;)

val ab4 = P ( &quot;a&quot;.rep(min=2, max=4, sep=&quot;b&quot;) )
val Parsed.Success(_, 7) = ab4.parse(&quot;ababababababa&quot;)

val ab4c = P ( &quot;a&quot;.rep(min=2, max=4, sep=&quot;b&quot;) ~ &quot;c&quot; )
val Parsed.Failure(_, 1, _) = ab4c.parse(&quot;ac&quot;)
val Parsed.Success(_, 4) = ab4c.parse(&quot;abac&quot;)
val Parsed.Success(_, 8) = ab4c.parse(&quot;abababac&quot;)
val Parsed.Failure(_, 7, _) = ab4c.parse(&quot;ababababac&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L37-L53" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> method creates a new parser that attempts to parse the given parser zero or more times. If you want to parse something a given number of times, you can use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(min = 2, max = 4)</code> or the shorter <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(1)</code> for one or more times. You can optionally provide an argument which acts as a separator between the usages of the original parser, such as a comma in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(sep = &quot;,&quot;)</code>.
</p>
            <h2 id="Optional" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Optional" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Optional</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val option = P( &quot;c&quot;.? ~ &quot;a&quot;.rep(sep=&quot;b&quot;).! ~ End)

val Parsed.Success(&quot;aba&quot;, 3) = option.parse(&quot;aba&quot;)
val Parsed.Success(&quot;aba&quot;, 3) = option.parse(&quot;aba&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L56-L60" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Similar to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>, which creates a new parser that attempts to parse the given parser zero or 1 times.
</p>
            <h2 id="Either" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Either" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Either</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val either = P( &quot;a&quot;.rep ~ (&quot;b&quot; | &quot;c&quot; | &quot;d&quot;) ~ End)

val Parsed.Success(_, 6) = either.parse(&quot;aaaaab&quot;)
val Parsed.Failure(parser, 5, _) = either.parse(&quot;aaaaae&quot;)
assert(parser == (&quot;b&quot; | &quot;c&quot; | &quot;d&quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L63-L68" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code> operator tries the parser on the left, and if that fails, tries the one on the right, failing only if both parsers fail.
</p>
            <h2 id="End,Start" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#End,Start" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>End, Start</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val noEnd = P( &quot;a&quot;.rep ~ &quot;b&quot;)
val withEnd = P( &quot;a&quot;.rep ~ &quot;b&quot; ~ End)

val Parsed.Success(_, 4) = noEnd.parse(&quot;aaaba&quot;)
val Parsed.Failure(End, 4, _) = withEnd.parse(&quot;aaaba&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L72-L78" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code> parser only succeeds if at the end of the input string. By default, a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code> does not need to consume the whole input, and can succeed early consuming a portion of it (exactly how much input was consumed is stored in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#index</code> attribute). By using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code>, we can make the parse fail if it doesn't consume everything
</p>
                <p>
                    There is also a similar <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Start</code> parser, which only succeeds at the start of the input</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( ((&quot;a&quot; | Start) ~ &quot;b&quot;).rep ~ End).!

val Parsed.Success(&quot;abab&quot;, 4) = ab.parse(&quot;abab&quot;)
val Parsed.Success(&quot;babab&quot;, 5) = ab.parse(&quot;babab&quot;)

val Parsed.Failure(parser, 2, _) = ab.parse(&quot;abb&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L80-L87" target="_blank"><i class="fa fa-link "></i></a></pre>

            <h2 id="Pass,Fail" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Pass,Fail" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Pass, Fail</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success((), 0) = Pass.parse(&quot;asdad&quot;)
val Parsed.Failure(Fail, 0, _) = Fail.parse(&quot;asdad&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L90-L92" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    These two parsers always succeed, or always fail, respectively. Neither consumes any input.
</p>
            <h2 id="Index" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Index" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Index</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val finder = P( &quot;hay&quot;.rep ~ Index ~ &quot;needle&quot; ~ &quot;hay&quot;.rep )

val Parsed.Success(9, _) = finder.parse(&quot;hayhayhayneedlehay&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L95-L98" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Always succeeds, and provides the current index of the parse into the input string. e.g. useful for providing source locations for AST nodes. Consumes no input.
</p>
            <h2 id="Capture" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Capture" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Capture</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val capture1 = P( &quot;a&quot;.rep.! ~ &quot;b&quot; ~ End)

val Parsed.Success(&quot;aaa&quot;, 4) = capture1.parse(&quot;aaab&quot;)

val capture2 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;), 4) = capture2.parse(&quot;aaab&quot;)

val capture3 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ &quot;c&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;, &quot;c&quot;), 5) = capture3.parse(&quot;aaabc&quot;)

val captureRep = P( &quot;a&quot;.!.rep ~ &quot;b&quot; ~ End)

val Parsed.Success(Seq(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;), 4) = captureRep.parse(&quot;aaab&quot;)

val captureOpt = P( &quot;a&quot;.rep ~ &quot;b&quot;.!.? ~ End)

val Parsed.Success(Some(&quot;b&quot;), 4) = captureOpt.parse(&quot;aaab&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L101-L120" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    So far, all the parsers go over the input text but do not return any useful value: the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#value</code> attribute was always <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">()</code>. In order to make them do so, you use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code> operation to capture the section of the input string the parser parsed.</p>
                <p>
                    Note the types of each parser:</p>
                <ul>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture1</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[String]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture2</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[(String, String)]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture3</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[(String, String, String)]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureRep</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[String]]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureOpt</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[String]]</code></li></ul>
                <p>
                    In general, if you have a parser of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN</code>, capturing one more section turns it into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN+1</code>. Furthermore, if you capture within a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code> optional parser, it becomes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[T]]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[T]]</code> respectively</p>
            <h2 id="AnyChar" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AnyChar" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>AnyChar</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;'&quot; ~ AnyChar.! ~ &quot;'&quot; )

val Parsed.Success(&quot;-&quot;, 3) = ab.parse(&quot;'-'&quot;)

val Parsed.Failure(parser, 2, _) = ab.parse(&quot;'-='&quot;)
assert(parser == (&quot;'&quot;: P0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L122-L128" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    This parser parses any single character successfully.
</p>
            <h2 id="PositiveLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PositiveLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Positive Lookahead</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val keyword = P( (&quot;hello&quot; ~ &amp;(&quot; &quot;)).!.rep )

val Parsed.Success(Seq(&quot;hello&quot;), _) = keyword.parse(&quot;hello &quot;)
val Parsed.Success(Seq(), __) = keyword.parse(&quot;helloX&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L132-L136" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&amp;(...)</code> operator wraps a parser, only succeeds if it succeeds, but consumes no input. Useful for doing checks like &quot;these characters must be followed by a whitespace, but don't consume the whitespace&quot;
</p>
            <h2 id="NegativeLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NegativeLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Negative Lookahead</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val keyword = P( &quot;hello&quot; ~ !&quot; &quot; ~ AnyChar ~ &quot;world&quot; ).!

val Parsed.Success(&quot;hello-world&quot;, _) = keyword.parse(&quot;hello-world&quot;)
val Parsed.Success(&quot;hello_world&quot;, _) = keyword.parse(&quot;hello_world&quot;)

val Parsed.Failure(parser, 6, _) = keyword.parse(&quot;hello world&quot;)
assert(parser == !(&quot; &quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L138-L145" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">!...</code> operator wraps a parser and only succeeds of it fails, also consuming no input. Useful to combine with other parsers like <a href="#AnyChar">AnyChar</a> to restrict the things that they can parse.</p>
            <h2 id="Map" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Map" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Map</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val binary = P( (&quot;0&quot; | &quot;1&quot; ).rep.! )
val binaryNum = P( binary.map(Integer.parseInt(_, 2)) )

val Parsed.Success(&quot;1100&quot;, _) = binary.parse(&quot;1100&quot;)
val Parsed.Success(12, _) = binaryNum.parse(&quot;1100&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L147-L152" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    Up till now, we've only dealt with</p>
                <ul>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit]</code>: the default case</li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[String]</code>: after capturing something with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[TupleN[String]]</code>: capturing multiple things in series</li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[String]]</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[String]]</code>: capturing things in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>
</li></ul>
                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> lets you convert an arbitrary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code> into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[V]</code> by providing a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; V</code> function. This is useful for converting the strings and tuples/seqs/options of strings into more useful data-structures.</p>
            <h2 id="FlatMap" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FlatMap" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>FlatMap</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val leftTag = P( &quot;&lt;&quot; ~ (!&quot;&gt;&quot; ~ AnyChar).rep(1).! ~ &quot;&gt;&quot; )
def rightTag(s: String) = P( &quot;&lt;/&quot; ~ s.! ~ &quot;&gt;&quot; )
val xml = P( leftTag.flatMap(rightTag) )

val Parsed.Success(&quot;a&quot;, _) = xml.parse(&quot;&lt;a&gt;&lt;/a&gt;&quot;)
val Parsed.Success(&quot;abcde&quot;, _) = xml.parse(&quot;&lt;abcde&gt;&lt;/abcde&gt;&quot;)

val failure = xml.parse(&quot;&lt;abcde&gt;&lt;/edcba&gt;&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.extra.traced.trace == &quot;&quot;&quot;xml:1:1 / rightTag:1:8 / &quot;abcde&quot;:1:10 ...&quot;edcba&gt;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L154-L165" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> allows you to dynamically choose a parser to continue with, given the result of the current parser. The example above uses it to parse balanced XML tags. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> can be used to parse indentation-based grammars, and is used to do so in <a href="http://lihaoyi.github.io/Scalatex/">Scalatex</a>.
</p>
                <p>
                    Note that the function given to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> is evaluated every time this parser is tried. You should be conscious of the cost of re-creating the resultant parser every time, since FastParse parsers are somewhat expensive to initialize despite being fast per-run. If possible, store the parsers somewhere before-hand or memo-ize/cache them to avoid initializing them wastefully.</p>
            <h2 id="Filter" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Filter" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Filter</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P(CharIn('0' to '9').rep(1).!).map(_.toInt)
val even = digits.filter(_ % 2 == 0)
val Parsed.Success(12, _) = even.parse(&quot;12&quot;)
val failure = even.parse(&quot;123&quot;).asInstanceOf[Parsed.Failure]
assert(even.toString == &quot;digits.filter(&lt;function1&gt;)&quot;)
assert(failure.extra.traced.trace == &quot;digits.filter(&lt;function1&gt;):1:1 ...\&quot;123\&quot;&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L167-L173" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> allows you to supply a predicate <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; Boolean</code> which is applied to the successful result of the current parser. If the predicate is true the filtered parser succeeds otherwise it fails. The example above uses <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> on digits to parse only even numbers successfully while odd numbers will fail. If the current parser fails then that failure is simply passed along.</p>
            <h2 id="Opaque" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Opaque" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Opaque</h2>
                <p>
                    Sometimes it's useful to hide parser's implementation details and provide a higher-level error message. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.opaque</code> achieves exactly that.</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digit = CharIn('0' to '9')
val letter = CharIn('A' to 'Z')
def twice[T](p: Parser[T]) = p ~ p
def errorMessage[T](p: Parser[T], str: String) =
  ParseError(p.parse(str).asInstanceOf[Parsed.Failure]).getMessage

// Portuguese number plate format since 2006
val numberPlate = P(twice(digit) ~ &quot;-&quot; ~ twice(letter) ~ &quot;-&quot; ~ twice(digit))

assert(errorMessage(numberPlate, &quot;11-A1-22&quot;) == &quot;&quot;&quot;
  |found &quot;1-22&quot;, expected CharIn(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;) at index 4
  |11-A1-22
  |    ^&quot;&quot;&quot;.stripMargin.trim)

// Suppress implementation details from the error message
val opaqueNumberPlate = numberPlate.opaque(&quot;&lt;number-plate&gt;&quot;)

assert(errorMessage(opaqueNumberPlate, &quot;11-A1-22&quot;) == &quot;&quot;&quot;
  |found &quot;11-A1-22&quot;, expected &lt;number-plate&gt; at index 0
  |11-A1-22
  |^&quot;&quot;&quot;.stripMargin.trim)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L175-L196" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.opaque</code> wraps the target parser in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Opaque</code> combinator, which only succeeds or fails as a single entity and leaves no traces of underlying parsers on the stack.
</p>
            <h2 id="Log" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Log" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Log</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val logged = mutable.Buffer.empty[String]
implicit val logger = fastparse.Logger(logged.append(_))

val DeepFailure = P( &quot;C&quot; )
val Foo = P( (DeepFailure.log() | &quot;A&quot;.log()) ~ &quot;B&quot;.!.log() ).log()

Foo.parse(&quot;AB&quot;)

val allLogged = logged.mkString(&quot;\n&quot;)

val expected =
  &quot;&quot;&quot;+Foo:0
    |  +DeepFailure:0
    |  -DeepFailure:0:Failure(DeepFailure:1:1 / &quot;C&quot;:1:1 ...&quot;AB&quot;)
    |  +&quot;A&quot;:0
    |  -&quot;A&quot;:0:Success(1)
    |  +&quot;B&quot;:1
    |  -&quot;B&quot;:1:Success(2)
    |-Foo:0:Success(2)
    |
  &quot;&quot;&quot;.stripMargin.trim
assert(allLogged == expected)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MiscTests.scala#L67-L89" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    <a href="#DebuggingParsers">Debugging Parsers</a> is often done with the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> method, which logs output whenever the parser is tried, and when it succeeds or fails, together with the location and other data when these things happen (traces on failures, results on successes, the presence of <a href="#Cuts">Cuts</a>, ...). You can define custom loggers as we've done here, or you can just leave it to by default print to stdout.
</p>
                <p>
                    Generally, if a parser is doing something wrong, the workflow is:
</p>
                <ul>
                    <li>
                        Add a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> to the parser which is misbehaving</li>
                    <li>
                        See where it's being tried, and what it's result (success/failure) is, and confirm that it is misbehaving.</li>
                    <li>
                        Look at the parsers it's made of; which one of them is misbehaving and causing the larger parser to misbehave?</li>
                    <li>
                        Add <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code>s to all of them</li>
                    <li>
                        Identify which of the sub-parsers is misbehaving</li>
                    <li>
                        Repeat</li></ul>
                <p>
                    It's a non-trivial process, but it is generally not hard to figure out what's happening this way.
</p>
        <h1 id="Intrinsics" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Intrinsics" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Intrinsics</h1>
            <p>
                In theory, all possible parsers can be put together using the above tools. In practice, a few more tools are provided for convenience or performance:
</p>
            <h2 id="CharPred" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharPred" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharPred</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cp = P( CharPred(_.isUpper).rep.! ~ &quot;.&quot; ~ End )

val Parsed.Success(&quot;ABC&quot;, _) = cp.parse(&quot;ABC.&quot;)
val Parsed.Failure(_, 2, _) = cp.parse(&quot;ABc.&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L200-L204" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharPred</code> takes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char =&gt; Boolean</code> predicate and creates a parser that parses any single character that satisfies that predicate. e.g. you can use any of the helpful methods on <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">scala.Char</code> to check if a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char</code> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isUpper</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isDigit</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isControl</code>, etc. etc.
</p>
                <p>
                    Note that this builds a high-performance bit-packed lookup table, the size of the range of valid characters, up to 65k. That means that creating a parser like this has a one-time cost in terms of memory (up to 8k bytes) and time. This should not matter as FastParse parsers are long-lived and re-usable, though you may want to consciously avoid creating too many of these repeatedly.
</p>
            <h2 id="CharIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharIn</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ci = P( CharIn(&quot;abc&quot;, &quot;xyz&quot;).rep.! ~ End )

val Parsed.Success(&quot;aaabbccxyz&quot;, _) = ci.parse(&quot;aaabbccxyz&quot;)
val Parsed.Failure(_, 7, _) = ci.parse(&quot;aaabbccdxyz.&quot;)

val digits = P( CharIn('0' to '9').rep.! )

val Parsed.Success(&quot;12345&quot;, _) = digits.parse(&quot;12345abcde&quot;)
val Parsed.Success(&quot;123&quot;, _) = digits.parse(&quot;123abcde45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L206-L215" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    Similar to <a href="#CharPred">CharPred</a>, except you pass in sequences of valid characters rather than a predicate.
</p>
                <p>
                    As a result, it's much faster to execute than if you had used <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | ...</code> to combine a bunch of single-character parsers together. The same warning as <a href="#CharPred">CharPred</a> about the one time cost-of-construction applies.
</p>
            <h2 id="CharsWhile" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharsWhile" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharsWhile</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cw = P( CharsWhile(_ != ' ').! )

val Parsed.Success(&quot;12345&quot;, _) = cw.parse(&quot;12345&quot;)
val Parsed.Success(&quot;123&quot;, _) = cw.parse(&quot;123 45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L217-L221" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    A repeated version of <a href="#CharPred">CharPred</a>: this parser continually chomps away at characters as long as they continue passes the given predicate.
</p>
                <p>
                    This is a very fast parser, ideal for quickly consuming large numbers of characters. The same warning as <a href="#CharPred">CharPred</a> about the one time cost-of-construction applies.
</p>
            <h2 id="StringIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StringIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>StringIn</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val si = P( StringIn(&quot;cow&quot;, &quot;cattle&quot;).!.rep )

val Parsed.Success(Seq(&quot;cow&quot;, &quot;cattle&quot;), _) = si.parse(&quot;cowcattle&quot;)
val Parsed.Success(Seq(&quot;cow&quot;), _) = si.parse(&quot;cowmoo&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L223-L227" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Quickly parses one of any number of strings that you give it. Behind the scenes, it converts the list of strings into a Trie so it can attempt to parse all of them in a single pass.
</p>
                <p>
                    As a result, this is much faster to execute than if you had combined the individual strings with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;cow&quot; | &quot;cattle&quot; | ...</code>.</p>
        <h1 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h1>
            <p>
                A &quot;cut&quot; is a marker in a recursive-descent parser that states &quot;you cannot backtrack past this point&quot;. Although in theory it allows you to save on memory usage by discarding earlier portions of the input, in FastParse this operator is mostly used to improve on the quality of error reporting.
</p>
            <h2 id="NoCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NoCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>No Cuts</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val nocut = P( &quot;val &quot; ~ alpha.rep(1).! | &quot;def &quot; ~ alpha.rep(1).!)

val Parsed.Success(&quot;abcd&quot;, _) = nocut.parse(&quot;val abcd&quot;)

val failure = nocut.parse(&quot;val 1234&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 0,
  failure.extra.traced.trace ==
  &quot;&quot;&quot;nocut:1:1 / (&quot;val &quot; ~ alpha.rep(1) | &quot;def &quot; ~ alpha.rep(1)):1:1 ...&quot;val 1234&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L231-L242" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    Above we have a naive scala definition parser: it either parses a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def</code>, a space, and its (lower-case only) name. On a success this works as expected, and extracts the name. However, on a failure, something odd happens: the deepest parser on-failure is shown to be the entire <a href="#Either">Either</a>, rather than just the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">alpha</code> that came after <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>. Why is that?
</p>
                <p>
                    By default, the parse has an opportunity to backtrack whenever it enters a
</p>
                <ul>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>: If <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> fails, it tries <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>
</li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.rep</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.?</code>: If parsing with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p</code> fails, it backtracks out of the failed parse and tries to parse whatever comes after the repeat/optional.</li></ul>
                <p>
                    e.g. in the case of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>, if it tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> and fails, it then tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>. If <i>that</i> fails, all that FastParse knows is that one of them should have succeeded. Specifically, FastParse does <i>not</i> know that after successfully parsing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>, that only the left branch of the <a href="#Either">Either</a> is viable! Thus it has no choice but to offer both alternatives in the error message.
</p>
            <h2 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val nocut = P( &quot;val &quot; ~/ alpha.rep(1).! | &quot;def &quot; ~/ alpha.rep(1).!)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L244-L247" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Cuts are added using the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> operator, which is similar to the <a href="#Sequence">Sequence</a> operator <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code>. Once the parse has crossed a cut, it can no longer backtrack past the point at which the cut occured. Hence, in this case you can see that it no longer backtracks to index 0, out of the enclosing <a href="#Either">Either</a> parser and offering that in the error trace. Instead, it shows a much more precise error: at index <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">4</code>, expecting one of the small set of alphanumeric characters.</p>
                <p>
                    In general, if you know that a parser is &quot;committed&quot; to one branch after parsing to a certain point, adding a cut will greatly improve the error message by ensuring that the parser <i>itself</i> knows that. Good places to add cuts include places like after keywords in a programming language parser, where a keyword can be followed by only one thing and anything else is an error.</p>
            <h2 id="RepCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#RepCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Rep Cuts</h2>

                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val stmt = P( &quot;val &quot; ~ alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
val stmts = P( stmt.rep(1) ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L257-L261" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    A similar problem occurs inside <a href="#Repeat">Repeat</a> or <a href="#Optional">Optional</a> parsers, where the parser will give up and backtrack out if it fails, even if it really should succeed. Again, adding cuts would result in a more precise error message:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val stmt = P( &quot;val &quot; ~/ alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
val stmts = P( stmt.rep(1) ~ End )

val Parsed.Success(Seq(&quot;abcd&quot;), _) = stmts.parse(&quot;val abcd;&quot;)
val Parsed.Success(Seq(&quot;abcd&quot;, &quot;efg&quot;), _) = stmts.parse(&quot;val abcd; val efg;&quot;)

val failure = stmts.parse(&quot;val abcd; val &quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 14,
  failure.extra.traced.trace ==
    &quot;&quot;&quot;stmts:1:1 / stmt:1:11 / alpha:1:14 / CharIn(&quot;abcdefghijklmnopqrstuvwxyz&quot;):1:14 ...&quot;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L270-L283" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Another case where you may want to pay attention is when you are using delimiters with your <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> calls:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 2,
  failure.extra.traced.trace == &quot;&quot;&quot;tuple:1:1 / (&quot;)&quot; | CharIn(&quot;0123456789&quot;)):1:3 ...&quot;,)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L285-L295" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    in many (but not all!) cases, if a delimiter is parsed, you want to commit to parsing one more iteration of the <a href="#Repeat">Repeat</a>. However, by default, it backtracks out of the <a href="#Repeat">Repeat</a> entirely and starts trying to parse the next item in sequence (in this case the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> giving the behavior shown above.
</p>
                <p>
                    With a cut, the error is improved:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot; ~/ Pass) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 3,
  failure.extra.traced.trace == &quot;&quot;&quot;tuple:1:1 / digits:1:4 / CharIn(&quot;0123456789&quot;):1:4 ...&quot;)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L297-L307" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> operator can be used without following parser as a shortcut for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/ Pass</code>. Compare the previous example with the following one:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;.~/) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Parsed.Failure]
val trace = failure.extra.traced.trace
assert(
  failure.index == 3,
  trace == &quot;&quot;&quot;tuple:1:1 / digits:1:4 / CharIn(&quot;0123456789&quot;):1:4 ...&quot;)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L309-L320" target="_blank"><i class="fa fa-link "></i></a></pre>

            <h2 id="IsolatingCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IsolatingCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Isolating Cuts</h2>
                <p>
                    Because cuts prevent backtracking throughout the entire parser, they make it difficult to compose arbitrary parsers:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digit = P( CharIn('0' to '9') )
val time1 = P( (&quot;1&quot;.? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit ~ (&quot;am&quot; | &quot;pm&quot;) )
val time2 = P( ((&quot;1&quot; | &quot;2&quot;).? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit )
val Parsed.Success((), _) = time1.parse(&quot;12:30pm&quot;)
val Parsed.Success((), _) = time2.parse(&quot;17:45&quot;)
val time = P( time1 | time2 )
val Parsed.Success((), _) = time.parse(&quot;12:30pm&quot;)
val failure = time.parse(&quot;17:45&quot;).asInstanceOf[Parsed.Failure]
assert(failure.index == 5)  // Expects am or pm</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L322-L331" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    In the above case, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time2</code> are arbitrary parsers containing <a href="#Cuts">Cuts</a>. By default, that means that once you've crossed a cut, you can no longer backtrack. However, there are cases where you want to use an existing parser (for example <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code>) in a situation where you want to allow it to backtrack, but you don't want to rewrite it identically but without cuts. In this case it's trivial, but if <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code> was larger you would need to rewrite all of it as well as all of its transitive sub-parsers to make sure that not a single one had a cut inside!
</p>
                <p>
                    To explicitly isolate a cut to one branch of a parser, place that branch within <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">NoCut</code>.  Cuts within that branch will prevent backtracking inside that branch, but if that branch fails alternate branches will be tried as normal.
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digit = P( CharIn('0' to '9') )
val time1 = P( (&quot;1&quot;.? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit ~ (&quot;am&quot; | &quot;pm&quot;) )
val time2 = P( ((&quot;1&quot; | &quot;2&quot;).? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit )
val Parsed.Success((), _) = time1.parse(&quot;12:30pm&quot;)
val Parsed.Success((), _) = time2.parse(&quot;17:45&quot;)
val time = P( NoCut(time1) | time2 )
val Parsed.Success((), _) = time.parse(&quot;12:30pm&quot;)
val Parsed.Success((), _) = time.parse(&quot;17:45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L333-L341" target="_blank"><i class="fa fa-link "></i></a></pre>

    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ExampleParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Example Parsers<a class=" scalatex-site-Styles-headerLink" href="#ExampleParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            Above, we've already covered all the individual bits and pieces that make writing a parser possible. But how does that fit together? Let's take a look at some examples.
</p>
        <h1 id="Math" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Math" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Math</h1>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)
val expr: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L18-L26" target="_blank"><i class="fa fa-link "></i></a></pre>


            <p>
                This is a small arithmetic expression parser, the same one shown at the top of this page. It parses only whole integers, parentheses, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">+-*/</code>, and no whitespace.</p>
            <p>
                Things to note:
</p>
            <ul>
                <li>
                    The various sub-parsers are all of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Int]</code>, indicating that they result in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Int</code> if successful. Many of the type annotations could be removed due to type-inference, but they're shown here for clarity</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">divMul</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">addSub</code> are separated out, in order to properly account for precedence</li>
                <li>
                    We evaluate the expression as the parse progresses, meaning we never actually build an tree structure from the input string</li>
                <li>
                    In order to convert the parsed strings to integers, we <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">map</code> on the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">eval</code> function, which itself is defined earlier:
</li></ul>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def eval(tree: (Int, Seq[(String, Int)])) = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L10-L18" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This is a small example, but it works. We check it using a helper to verify that every parse results in the expected integer:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Parsed.Success(value, _) = expr.parse(str)
  assert(value == num)
}

check(&quot;1+1&quot;, 2)
check(&quot;1+1*2&quot;, 3)
check(&quot;(1+1*2)+(3*4*5)&quot;, 63)
check(&quot;15/3&quot;, 5)
check(&quot;63/3&quot;, 21)
check(&quot;(1+1*2)+(3*4*5)/20&quot;, 6)
check(&quot;((1+1*2)+(3*4*5))/3&quot;, 21)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L28-L40" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Try it out yourself! Remember that it does not handle whitespace:
</p>
            <div id="mathdiv"></div>
            <script>demo.DemoMain().math(document.getElementById("mathdiv"))</script>
        <h1 id="WhitespaceHandling" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhitespaceHandling" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Whitespace Handling</h1>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val White = WhitespaceApi.Wrapper{
  import fastparse.all._
  NoTrace(&quot; &quot;.rep)
}
import fastparse.noApi._
import White._
def eval(tree: (Int, Seq[(String, Int)])): Int = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}
val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)
val expr: P[Int]   = P( &quot; &quot;.rep ~ addSub ~ &quot; &quot;.rep ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/WhiteSpaceMathTests.scala#L9-L30" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                To handle whitespace and other non-significant characters with FastParse, use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WhitespaceApi</code> as a substitue for the normal API that is provided for parsers. This modifies the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> operators to consume all non-trailing whitespace and ignoring it.
</p>
            <p>
                Note how you can pass in whatever definition of whitespace you want: here we're passing in a simple <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot; &quot;.rep</code>, but in a more sophisticated parser you may wish to include tabs, newlines, comments or even nested comments. The whitespace parser can be arbitrarily complex.
</p>
            <p>
                Note also how we're importing from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.noApi</code> instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.all</code>, and then substituting it with our one whitespace-consuming parser API. Other than that, the parser is identical except for added whitespace parsers at the start and end of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> rule.
</p>
            <p>
                Here it is in action:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Parsed.Success(value, _) = expr.parse(str)
  assert(value == num)
}

* - check(&quot;1+1&quot;, 2)
* - check(&quot;1+   1*   2&quot;, 3)
* - check(&quot;(1+   1  *  2)+(   3*4*5)&quot;, 63)
* - check(&quot;15/3&quot;, 5)
* - check(&quot;63  /3&quot;, 21)
* - check(&quot;(1+    1*2)+(3      *4*5)/20&quot;, 6)
* - check(&quot;((1+      1*2)+(3*4*5))/3&quot;, 21)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/WhiteSpaceMathTests.scala#L32-L44" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Or try it yourself:
</p>
            <div id="wsmathdiv"></div>
            <script>demo.DemoMain().whitespaceMath(document.getElementById("wsmathdiv"))</script>

        <h1 id="IndentationGrammars" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IndentationGrammars" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Indentation Grammars</h1>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def eval(tree: (String, Seq[Int])) = tree match{
  case (&quot;+&quot;, nums) =&gt; nums.reduceLeft(_+_)
  case (&quot;-&quot;, nums) =&gt; nums.reduceLeft(_-_)
  case (&quot;*&quot;, nums) =&gt; nums.reduceLeft(_*_)
  case (&quot;/&quot;, nums) =&gt; nums.reduceLeft(_/_)
}

/**
 * Parser for an indentation-based math syntax. Parens are no longer
 * necessary, and the whole parser is parametrized with the current
 * depth of indentation
 */
class Parser(indent: Int){
  val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )

  val deeper: P[Int] = P( &quot; &quot;.rep(indent + 1).!.map(_.length) )
  val blockBody: P[Seq[Int]] = &quot;\n&quot; ~ deeper.flatMap(i =&gt;
    new Parser(indent = i).factor.rep(1, sep = (&quot;\n&quot; + &quot; &quot; * i).~/)
  )
  val block: P[Int] = P( CharIn(&quot;+-*/&quot;).! ~/ blockBody).map(eval)

  val factor: P[Int] = P( number | block )

  val expr: P[Int]   = P( block ~ End )
}
val expr = new Parser(indent = 0).expr</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/IndentationTests.scala#L8-L34" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Here is a grammar that is used to parse a simple indentation-based math grammar. To understand the grammar it is trying to parse, it is worth looking at the test data:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Parsed.Success(value, _) = expr.parse(str)
  assert(value == num)
}

check(
  &quot;&quot;&quot;+
    |  1
    |  1
  &quot;&quot;&quot;.stripMargin.trim,
  2
)
check(
  &quot;&quot;&quot;+
    |  1
    |  *
    |    1
    |    2
  &quot;&quot;&quot;.stripMargin.trim,
  3
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/IndentationTests.scala#L36-L58" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                As you can see, it is basically a prefix math evaluator, where you use indentation to pass the numbers or expressions to each operator to operate on.
</p>
            <p>
                As for the parser, the novel things are:
</p>
            <ul>
                <li>
                    All the rules live in a class parametrized on the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">indent</code> that is currently in place</li>
                <li>
                    At each level, the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">factor</code>s (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">number</code>s or further <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">block</code>s) inside a block are separated by a newline and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">indent</code> spaces</li>
                <li>
                    The initial top-level <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> rule starts off with indentation <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">0</code></li>
                <li>
                    After parsing an operator, we use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">deeper</code> to figure out how deep the first line of the indented block is.</li>
                <li>
                    We then use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> to increment the indentation to the new value and parse the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">factor</code>s at that indentation.
</li></ul>
            <p>
                Note how there is no pre-processing, and no lexining phase where the lexer has to guess where in the token stream to inject synthetic indent and dedent tokens, Everything happens in a single pass.</p>
            <p>
                Try it out!</p>
            <div id="indentdiv"></div>
            <script>demo.DemoMain().indentation(document.getElementById("indentdiv"))</script>

        <h1 id="Json" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Json" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Json</h1>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Here is the parser
val Whitespace = NamedFunction(&quot; \r\n&quot;.contains(_: Char), &quot;Whitespace&quot;)
val Digits = NamedFunction('0' to '9' contains (_: Char), &quot;Digits&quot;)
val StringChars = NamedFunction(!&quot;\&quot;\\&quot;.contains(_: Char), &quot;StringChars&quot;)

val space         = P( CharsWhile(Whitespace).? )
val digits        = P( CharsWhile(Digits))
val exponent      = P( CharIn(&quot;eE&quot;) ~ CharIn(&quot;+-&quot;).? ~ digits )
val fractional    = P( &quot;.&quot; ~ digits )
val integral      = P( &quot;0&quot; | CharIn('1' to '9') ~ digits.? )

val number = P( CharIn(&quot;+-&quot;).? ~ integral ~ fractional.? ~ exponent.? ).!.map(
  x =&gt; Js.Num(x.toDouble)
)

val `null`        = P( &quot;null&quot; ).map(_ =&gt; Js.Null)
val `false`       = P( &quot;false&quot; ).map(_ =&gt; Js.False)
val `true`        = P( &quot;true&quot; ).map(_ =&gt; Js.True)

val hexDigit      = P( CharIn('0'to'9', 'a'to'f', 'A'to'F') )
val unicodeEscape = P( &quot;u&quot; ~ hexDigit ~ hexDigit ~ hexDigit ~ hexDigit )
val escape        = P( &quot;\\&quot; ~ (CharIn(&quot;\&quot;/\\bfnrt&quot;) | unicodeEscape) )

val strChars = P( CharsWhile(StringChars) )
val string =
  P( space ~ &quot;\&quot;&quot; ~/ (strChars | escape).rep.! ~ &quot;\&quot;&quot;).map(Js.Str)

val array =
  P( &quot;[&quot; ~/ jsonExpr.rep(sep=&quot;,&quot;.~/) ~ space ~ &quot;]&quot;).map(Js.Arr(_:_*))

val pair = P( string.map(_.value) ~/ &quot;:&quot; ~/ jsonExpr )

val obj =
  P( &quot;{&quot; ~/ pair.rep(sep=&quot;,&quot;.~/) ~ space ~ &quot;}&quot;).map(Js.Obj(_:_*))

val jsonExpr: P[Js.Val] = P(
  space ~ (obj | array | string | `true` | `false` | `null` | number) ~ space
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L41-L80" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This is a somewhat larger example than the math parser shown above. In it, we parse a JSON expression from a string, including all the proper handling for whitespace and error-handling built in.
</p>
            <p>
                Things to note:
</p>
            <ul>
                <li>
                    We use cuts (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code>) liberally in order to improve the quality of errors. Anywhere there's an <a href="#Either">Either</a> or <a href="#Repeat">Repeat</a>, the children have cuts once the parse has progressed far enough backtracking isn't an option.</li>
                <li>
                    We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharIn</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> quite a lot, in order to speed up the common case of consuming lots of boring characters.</li>
                <li>
                    In <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code>, we break out of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> closing quote (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'&quot;'</code>) or whenever we see the start of an escape sequence (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'\'</code>). Although <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> can't process these multi-char sequences, we let the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">escape</code> parser deal with these before trying to fall back to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code> after. This lets us speed up the &quot;common&quot; case of consuming large numbers of non-escape characters, while still properly handling escapes.</li>
                <li>
                    We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> to convert the various things we parse into instances of our own <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.Val</code> JSON AST:

</li></ul>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Js {
  sealed trait Val extends Any {
    def value: Any
    def apply(i: Int): Val = this.asInstanceOf[Arr].value(i)
    def apply(s: java.lang.String): Val =
      this.asInstanceOf[Obj].value.find(_._1 == s).get._2
  }
  case class Str(value: java.lang.String) extends AnyVal with Val
  case class Obj(value: (java.lang.String, Val)*) extends AnyVal with Val
  case class Arr(value: Val*) extends AnyVal with Val
  case class Num(value: Double) extends AnyVal with Val
  case object False extends Val{
    def value = false
  }
  case object True extends Val{
    def value = true
  }
  case object Null extends Val{
    def value = null
  }
}

case class NamedFunction[T, V](f: T =&gt; V, name: String) extends (T =&gt; V){
  def apply(t: T) = f(t)
  override def toString() = name

}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L14-L41" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                We can verify that this parser builds the JSON tree that we expect:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success(value, _) = jsonExpr.parse(
  &quot;&quot;&quot;{&quot;omg&quot;: &quot;123&quot;, &quot;wtf&quot;: 12.4123}&quot;&quot;&quot;
)
assert(value == Js.Obj(&quot;omg&quot; -&gt; Js.Str(&quot;123&quot;), &quot;wtf&quot; -&gt; Js.Num(12.4123)))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L96-L100" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                And that it provides good error messages in the case of mal-formed JSON, even for moderately-sized fragemnts
</p>
            
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">{
    &quot;firstName&quot;: &quot;John&quot;,
    &quot;lastName&quot;: &quot;Smith&quot;,
    &quot;age&quot;: 25,
    &quot;address&quot;: {
        &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,
        &quot;city&quot;: &quot;New York&quot;,
        &quot;state&quot;: &quot;NY&quot;,
        &quot;postalCode&quot;: 10021
    },
    &quot;phoneNumbers&quot;:
        {
            &quot;type&quot;: &quot;home&quot;,
            &quot;number&quot;: &quot;212 555-1234&quot;
        },
        {
            &quot;type&quot;: &quot;fax&quot;,
            &quot;number&quot;: &quot;646 555-4567&quot;
        }
    ]
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L277-L298" target="_blank"><i class="fa fa-link "></i></a></pre>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">jsonExpr:1:0 / obj:2:9 / pair:16:18 / string:16:18 / &quot;\&quot;&quot;:17:17 ...&quot;{\n        &quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L300-L301" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Here, we're missing a square bracket after the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;phoneNumbers&quot;</code> key, and so the parser expects to find a single JSON expression. It finds a JSON object, and then fails reporting that it expected to find the next key (a string), but instead found <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;{\n&quot;</code> at that index.
</p>
            <p>
                Try it out!
</p>
            <div id="jsondiv"></div>
            <script>demo.DemoMain().json(document.getElementById("jsondiv"))</script>
        <h1 id="PythonParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PythonParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>PythonParse</h1>
            <p>
                There is now an <a href="https://github.com/lihaoyi/fastparse/tree/master/pythonparse/shared/src/main/scala/pythonparse">example Python parser</a> available under a subproject in the repo. This is a good example of a real-world parser: parsing knotty syntax (including indentation-delimited blocks!), building an AST, and with heavy unit tests.
</p>
            <p>
                PythonParse is currently compatible enough to parse all the python sources in Zulip, Ansible, Changes, Django, and Flask. It isn't published yet on maven central, but feel free to look at it if you want an idea of how to write a complex, real parser.
</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="APIHighlights" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">API Highlights<a class=" scalatex-site-Styles-headerLink" href="#APIHighlights" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

        <h1 id="Parser[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Parser[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Parser[T]</h1>
            <p>
                Fastparse revolves around <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code>s: a parser that can attempt to parser a value <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code> from an input string. These are defined as:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * A single, self-contained, immutable parser. The primary method is
 * `parse`, which returns a [[T]] on success and a stack trace on failure.
 *
 * Some small optimizations are performed in-line: collapsing [[parsers.Combinators.Either]]
 * cells into large ones and collapsing [[parsers.Combinators.Sequence]] cells into
 * [[parsers.Combinators.Sequence.Flat]]s. These optimizations together appear to make
 * things faster but any 10%, whether or not you activate tracing.
 */
trait Parser[+T] extends ParserResults[T] with Precedence{
  /**
   * Parses the given `input` starting from the given `index`
   *
   * @param input The string we want to parse
   *
   * @param index The index in the string to start from. By default parsing
   *              starts from the beginning of a string, but you can start
   *              from halfway through the string if you want.
   *
   * @param instrument Allows you to pass in a callback that will get called
   *                   by every named rule, its index, as it itself given a
   *                   callback that can be used to recurse into the parse and
   *                   return the result. Very useful for extracting auxiliary
   *                   information from the parse, e.g. counting rule
   *                   invocations to locate bottlenecks or unwanted
   *                   backtracking in the parser.
   */
  def parse(input: String,
            index: Int = 0,
            instrument: (Parser[_], Int, () =&gt; Parsed[_]) =&gt; Unit = null)
            : Parsed[T] = {
    parseRec(new ParseCtx(input, 0, -1, this, index, instrument), index).toResult
  }

  /**
   * Parses the given `input` starting from the given `index` and `logDepth`
   */
  def parseRec(cfg: ParseCtx, index: Int): Mutable[T]

  /**
   * Whether or not this parser should show up when [[Parsed.TracedFailure.trace]] is
   * called. If not set, the parser will only show up in [[Parsed.TracedFailure.fullStack]]
   */
  def shortTraced: Boolean = false

  /**
   * Whether or not to surround this parser with parentheses when printing.
   * By default a top-level parser is always left without parentheses, but
   * if a sub-parser is embedded inside with lower precedence, it will be
   * surrounded. Set to `Integer.MaxValue` to never be parenthesized
   */
  def opPred: Int = Precedence.Max
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L319-L372" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The main external API is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parse</code>. As you can see, apart from the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">input</code> parameter, there are a few parameters that you can use to configure the parse. Apart from that, each <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code> needs to implement <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">parseRec</code> which is a less-convenient but more-performant version that FastParse uses internally when performing a parse.</p>
            <p>
                Although the core of <a href="#Parser[T]">Parser[T]</a> is simple, a lot of additional functionality is included in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ParserApi[T]</code> trait in order to make constructing parsers convenient and concise.
</p>
        <h1 id="ParserApi[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ParserApi[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ParserApi[T]</h1>
            <p>
                Apart from the core <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>, FastParse includes a large set of operations that you can perform on a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code> to make composing them more pleasant. These all live in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ParserApi</code>:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">trait ParserApi[+T] {

  /**
   * Wraps this in a [[Logged]]. This prints out information
   * where a parser was tried and its result, which is useful for debugging
   */
  def log(msg: String = this.toString)(implicit output: Logger): Parser[T]

  /**
   * Makes this parser opaque, i.e. hides it and its inner parsers
   * from the stack trace, providing the specified message instead.
   */
  def opaque(msg: String = this.toString): Parser[T]

  /**
   * Repeats this parser 0 or more times
   */
  def rep[R](implicit ev: Repeater[T, R]): Parser[R]
  def rep[R](min: Int = 0,
             sep: Parser[_] = Pass,
             max: Int = Int.MaxValue)
            (implicit ev: Repeater[T, R]): Parser[R]

  /**
   * Parses using this or the parser `p`
   */
  def |[V &gt;: T](p: Parser[V]): Parser[V]

  /**
   * Parses using this followed by the parser `p`
   */
  def ~[V, R](p: Parser[V])(implicit ev: Sequencer[T, V, R]): Parser[R]
  /**
   * Parses using this followed by the parser `p`, performing a Cut if
   * this parses successfully. That means that if `p` fails to parse, the
   * parse will fail immediately and not backtrack past this success.
   *
   * This lets you greatly narrow the error position by avoiding unwanted
   * backtracking.
   */
  def ~/[V, R](p: Parser[V])(implicit ev: Sequencer[T, V, R]): Parser[R]

  /**
   * Performs a cut if this parses successfully.
   */
  def ~/ : Parser[T]
  /**
   * Parses this, optionally
   */
  def ?[R](implicit ev: Optioner[T, R]): Parser[R]

  /**
   * Wraps this in a [[Not]] for negative lookaheak
   */
  def unary_! : Parser[Unit]

  /**
   * Used to capture the text parsed by this as a `String`
   */
  def ! : Parser[String]

  /**
   * Transforms the result of this Parser with the given function
   */
  def map[V](f: T =&gt; V): Parser[V]
  /**
   * Uses the result of this parser to create another parser that
   * will be used for the next parse
   */
  def flatMap[V](f: T =&gt; Parser[V]): Parser[V]

  /**
   * applies the supplied predicate to the current parser succeeding on true failing on false
   */
  def filter(predicate: T =&gt; Boolean): Parser[T]
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/ParserApi.scala#L8-L85" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                There are essentially all short-hand constructors for the parsers in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">object Parser</code> companion. This is the list of operators that you have available when writing your own parsers using FastParse.</p>
            <p>
                As mentioned in <a href="#WhitespaceHandling">Whitespace Handling</a>, you can choose to ignore the default set of operators by using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi</code> instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all</code>. That way you can use your own set of operators, e.g. the whitespace-sensitive operators described in that section.</p>
        <h1 id="ParsingResults" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ParsingResults" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Parsing Results</h1>
            <p>
                The two kinds of a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code> result reflect the status of a parse: a success (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code>) or a failure (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code>). First, both classes can be used in pattern matching to discriminate the parse status. Second, they allow to extract the most commonly-used values. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> provides the parsed value - the value you are probably most interesed in - and the index in the input string till where the parse was performed. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code> allows you to retrieve the last parser that failed and the index where it failed. Additionally, failure provides an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure.extra</code> field that provides precise details about the failure: line and column numbers (via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.line</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.col</code>) and most importantly a complete stack trace of the involved parsers, which is accessible via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.traced</code>.
</p>
            <p>
                An overview of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * @param value The result of this parse
 * @param index The index where the parse completed; may be less than
 *              the length of input
 */
case class Success[+T](value: T, index: Int) extends Parsed[T]</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L65-L72" target="_blank"><i class="fa fa-link "></i></a></pre>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * Simple information about a parse failure. Also contains the original parse
 * information necessary to construct the traced failure. That contains more
 * information but is more costly to compute and is thus computed lazily on
 * demand.
 *
 * @param index The index in the parse where this parse failed
 * @param lastParser The deepest parser in the parse which failed
 * @param extra Extra supplementary information (including trace information).
 *              For details see [[Parsed.Failure.Extra]]
 */
case class Failure(lastParser: Parser[_],
                   index: Int,
                   extra: Failure.Extra) extends Parsed[Nothing]{

  def msg = Failure.formatStackTrace(
    Nil, extra.input, index, Failure.formatParser(lastParser, extra.input, index)
  )

  override def toString = s&quot;Failure($msg)&quot;
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L72-L94" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Note how <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code> only contains the parser which failed and a single index where the parse failed. Further debugging information is available via the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure.Extra</code> class. Especially the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TracedFailure</code> that is lazily-computed via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.traced</code>, provides valuable information: It performs a whole new parse on the input data with additional instrumentation, and provides additional insight into why the parse failed:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * A failure containing detailed information about a parse failure. This is more
 * expensive to compute than a simple error message and is thus not generated
 * by default.
 *
 * @param fullStack The entire stack trace where the parse failed, containing every
 *                  parser in the stack and the index where the parser was used, excluding
 *                  the final parser and index where the parse failed. Only set if
 *                  `parse` is called with `trace = true`, otherwise empty
 * @param traceParsers A list of parsers that could have succeeded at the location
 *                     that this
 */
case class TracedFailure(input: String,
                         index: Int,
                         fullStack: Vector[Frame],
                         traceParsers: Set[Parser[_]]){

  private[this] lazy val expected0 = new Precedence {
    def opPred = if (traceParsers.size == 1) traceParsers.head.opPred else Precedence.|
    override def toString = traceParsers.map(opWrap).mkString(&quot; | &quot;)
  }

  /**
   * A short string describing the parsers which were expected at the point
   * of failure.
   */
  def expected = expected0.toString

  /**
   * A slimmed down version of [[fullStack]], this only includes named
   * [[parsers.Combinators.Rule]] objects as well as the final Parser (whether named or not)
   * and index where the parse failed for easier reading.
   */
  lazy val stack = Failure.filterFullStack(fullStack)

  /**
   * A one-line snippet that tells you what the state of the parser was
   * when it failed. This message is completely derived from other values
   * available on this object, so feel free to use the data yourself if
   * the default error message isn't to your liking.
   */
  lazy val trace = {
    Failure.formatStackTrace(stack, input, index, Failure.formatParser(expected0, input, index))
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L147-L192" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Computing the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.traced</code> data is not done by default for performance reasons: the additional run takes about 3x longer than the initial run due to the instrumentation, for a total of 4x slowdown. If you want the information for debugging, though, it will be there.</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="DebuggingParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Debugging Parsers<a class=" scalatex-site-Styles-headerLink" href="#DebuggingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            The vast majority of your time working with FastParse, your parsers will be incorrect. This is almost by definition, because once your parser is correct, you'll be done and can go do something else with your life! Thus FastParse puts a lot of effort into making working with broken parsers as easy as possible
</p>
        <p>
            Let's take an example Parser:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{
  import fastparse.all._
  val plus = P( &quot;+&quot; )
  val num = P( CharIn('0' to '9').rep(1) ).!.map(_.toInt)
  val side = P( &quot;(&quot; ~ expr ~ &quot;)&quot; | num )
  val expr: P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L346-L355" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            This is a simple parser that parses some basic arithmetic expressions: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1+2</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(1+2)+(3+4)</code>, etc.
</p>
        <p>
            If we run the parser on a bad input, though, we get this:

</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">Foo.expr.parse(&quot;(1+(2+3x))+4&quot;),
&quot;&quot;&quot;Failure((&quot;(&quot; ~ expr ~ &quot;)&quot; | num):1:1 ...&quot;(1+(2+3x))&quot;)&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L356-L358" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            As you can see, the error message is pretty generic: &quot;i tried to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> or a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> at index <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">0</code>&quot;. Why does it tell us that?
</p>
        <h1 id="UsingCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using Cuts</h1>
            <p>
                The answer is that as far as FastParse knows, you could have wanted either the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> or the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> at that position, and it doesn't know which one. Thus even though it starts off parsing a paren, when that branch eventually fails (it tries to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> at index 7, but finds a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code>) it backtracks out of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> parser and then tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code>. When that fails, it doesn't know which side was &quot;meant&quot; to succeed, and so it gives up and just tells you both sides failed to parse.</p>
            <p>
                Although FastParse doesn't know which branch was meant to succeed, <i>we</i> know that once we've parsed a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>, it can no longer parse a number! Thus there's no point in backtracking and trying that side of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code>. We can tell FastParse this fact by adding <a href="#Cuts">Cuts</a> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> after <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{
  import fastparse.all._
  val plus = P( &quot;+&quot; )
  val num = P( CharIn('0' to '9').rep(1) ).!.map(_.toInt)
  val side = P( &quot;(&quot; ~/ expr ~ &quot;)&quot; | num )
  val expr: P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L362-L369" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Now, once FastParse sees a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>, it can no longer backtrack! Thus it knows that whatever error occurs later, it <i>must</i> be because it failed to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> and not because <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> failed. Then the error message becomes much more precise and useful:</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">Foo.expr.parse(&quot;(1+(2+3x))+4&quot;),
&quot;&quot;&quot;Failure(&quot;)&quot;:1:8 ...&quot;x))+4&quot;)&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L370-L372" target="_blank"><i class="fa fa-link "></i></a></pre>


        <h1 id="UsingLog" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingLog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using Log</h1>
            <p>
                We can add <a href="#Log">Log</a> calls to make FastParse tell us a lot more about what a parser is doing. For example, if we want to know whenever a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> is being attempted, we can add <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> to those to parsers to find out:</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{
  import fastparse.all._
  val plus = P( &quot;+&quot; )
  val num = P( CharIn('0' to '9').rep(1) ).!.map(_.toInt)
  val side = P( &quot;(&quot; ~/ expr ~ &quot;)&quot; | num ).log()
  val expr:P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}.log()
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L377-L386" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Then when you run it on an invalid input:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">Foo.expr.parse(&quot;(1+(2+3x))+4&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L386-L387" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                You get a dump of everything the logged parsers are trying to do
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">+expr:0
  +side:0
    +expr:1
      +side:1
      -side:1:Success(2)
      +side:3
        +expr:4
          +side:4
          -side:4:Success(5)
          +side:6
          -side:6:Success(7)
        -expr:4:Success(7)
      -side:3:Failure(side:1:4 / &quot;)&quot;:1:8 ...&quot;(2+3x))+4&quot;, cut)
    -expr:1:Failure(expr:1:2 / side:1:4 / &quot;)&quot;:1:8 ...&quot;1+(2+3x))+&quot;, cut)
  -side:0:Failure(side:1:1 / expr:1:2 / side:1:4 / &quot;)&quot;:1:8 ...&quot;(1+(2+3x))&quot;, cut)
-expr:0:Failure(expr:1:1 / side:1:1 / expr:1:2 / side:1:4 / &quot;)&quot;:1:8 ...&quot;(1+(2+3x))&quot;, cut)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L391-L407" target="_blank"><i class="fa fa-link "></i></a></pre>


            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">+</code> is when a parser is started, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">-</code> is when it finishes with either a success or a failure. In the case of failure, it tells you what the stack was when it failed.</p>
            <p>
                The general strategy for adding <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code>s is:
</p>
            <ol>
                <li>
                    Is my parser misbehaving? This is usually obvious from seeing parse failures when there shouldn't be</li>
                <li>
                    Are any sub-parsers which I believe should be succeeding/failing/getting-called, aren't? Add logging to the sub-parsers. You can do this at the definition-site of the sub-parsers as shown above, or to the use-site e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side.log(&quot;SIDE 1&quot;) ~ plus ~ side.log(&quot;SIDE 2&quot;)</code> if the parser is used in multiple places and you only want to log this usage.</li>
                <li>
                    Look at the logging, see some parser behaving strangely. Go to 1.
</li></ol>
            <p></p>


        <h1 id="Tracing" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tracing" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tracing</h1>
            <p>
                By default, on failure, FastParse only provides the index and the last parser which failed at that index. This is information FastParse already has and is thus cheap to provide, and often is enough to show what went wrong, and where. If you prefer row &amp; column, you can trivially compute that from the input &amp; index by counting newlines inside the input string.</p>
            <p>
                Often you want something more, though, and for that FastParse provides tracing, as described in the documentation of <a href="#ParsingResults">Parsing Results</a>. By accessing the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traced</code> lazy val on a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code>, FastParse will perform a whole second parse on the original input, starting from the same index, but with additional tracing code to keep track of what's happening. This typically costs ~2x as much as the original parse, so isn't done by default, but it's trivial to ask for it.</p>
            <p>
                For example, this is tracing being done on an invalid input we know will fail:
</p>
            <pre><code class="scala scalatex-site-Styles-highlightMe">val fail = Foo.expr.parse(&quot;(1+(2+3x))+4&quot;).asInstanceOf[fastparse.core.Parsed.Failure]</code></pre>
            <p>
                We know that this input will fail, because our grammar (defined earlier) does not contain an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code> in it! It only handles numbers and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;+&quot;</code> and parentheses. Let's see what information <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traced</code> gives us:
</p>
            <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; fail.traced.trace // The named parsers in the stack when it failed
expr:0 / side:0 / expr:1 / side:3 / (&quot;)&quot; | CharIn(&quot;0123456789&quot;)):7 ...&quot;x))+4&quot;

&gt; fail.traced.stack // Same as .trace, but as a List[Frame] rather than String
List(
 Frame(0,expr), // (1+(2+3x))+4
 Frame(0,side), // (1+(2+3x))+4
 Frame(1,expr), //  1+(2+3x))+4
 Frame(3,side)  //    (2+3x))+4
)

&gt; (fail.index, fail.lastParser) // Last index and last parser at which it failed
(7, &quot;)&quot;)         //        x))+4

</code></pre>
            <p>
                As you can see, tracing gives us a much more detailed view: every parser in the stack when the parse failed, what indices they were tried at. Apart from getting it as a readable string via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.trace</code>, you can also get it as structured data via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.stacK</code> in case you want to manipulate it programmatically.</p>
            <p>
                FastParse also provides the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traceParsers</code> value, which tells you every single parser which <i>could</i> have succeeded at the index parsing failed. In thi</p>
            <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; fail.traced.traceParsers // Every parser that could have succeeded at Failure#index
List(&quot;)&quot;, CharIn(&quot;0123456789&quot;))</code></pre>
            <p>
                Thus, we can see that although FastParse last tried the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> parser, it earlier <i>also</i> tried the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharIn(&quot;0123456789&quot;)</code> parser at the same spot. This makes perfect sense: if instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code> we had a digit of some kind, parsing could have continued! And we do not need to figure this out ourselves; FastParse knows and can tell you.</p>
            <p>
                Lastly, tracing gives you access to the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.fullStack</code> of the failure, which contains <i>every</i> parser in the stack when it failed, not just the ones with names!</p>
            <p>
                Every expression in a fastparse parser is itself a parser: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code> is a parser, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> is a parser, and so on. With <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.fullStack</code>, we can see in great detail what FastParse was trying to do when it failed:
</p>
            <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; fail.traced.fullStack // Every single parser in the stack when it failed
List(
 Frame(0,expr),   Frame(0,expr), Frame(0,side ~ plus ~ side),
 Frame(0,side),   Frame(0,&quot;(&quot; ~/ expr ~/ &quot;)&quot; | num), Frame(1,&quot;(&quot; ~/ expr ~/ &quot;)&quot;),
 Frame(1,expr),   Frame(1,expr), Frame(3,side ~ plus ~ side),
 Frame(3,side),   Frame(3,&quot;(&quot; ~/ expr ~/ &quot;)&quot; | num), Frame(7,&quot;(&quot; ~/ expr ~/ &quot;)&quot;)
)
&gt; (fail.index, fail.lastParser) // Last index and last parser at which it failed
(7, &quot;)&quot;)         //        x))+4
</code></pre>
        <h1 id="UseCases" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UseCases" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Use Cases</h1>
            <p>
                What's the purpose of all this detailed error reporting? The goal is three-fold:</p>
            <ul>
                <li>
                    You will want to know why parsers as misbehaving while you're writing them so you can fix bugs. Often <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traced.trace</code> is enough, but you can dig in more deeply if you wish to.</li>
                <li>
                    You can use the detailed error traces to your users when they enter invalid input. For example, instead of just <i>&quot;Syntax error at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">7</code>&quot;</i> You can say <i>&quot;Syntax error at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">7</code>, expected <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(&quot;)&quot; | CharIn(&quot;0123456789&quot;)</code>, while trying to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">3</code>, while trying to parse an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1</code>, ...&quot;</i>. Naturally, you do not need to overwhelm the user with debug information, but now you have the power to reveal as much or as little as you want.
</li>
                <li>
                    You can customize the experience of your users when they enter invalid input! For example, if I know that the rule <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> failing <i>usually</i> means the user made some common mistake, I can easily check for that via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fail.traced.stack.contains(_.parser == Foo.side)</code> and display a more helpful error <i>&quot;Maybe try X?&quot;</i> if it's found. No need to embed your error-reporting deep in the parser, just inspect the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">stack</code> and find out after the fact.</li></ul>
            <p>
                In general, FastParse's error reporting is detailed and structured. As a <i>developer</i>, most of your time spent interacting with your parser is when it is incorrect and throwing errors at you. As a <i>user</i>, most of your time spent interacting with the parser is when your input is incorrect and it is throwing errors at you. This is almost self-evident, since once your parser is correct or your input is correct you're done and go do other things</p>
            <p>
                Thus, FastParse makes an effort to make the error reporting both detailed and structured. This means as a developer you can quickly diagnose problems, and (if you wish to) put in effort to use the structured errors to help <i>your users</i> diagnose problems. That makes life better for everybody.
</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Performance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Performance<a class=" scalatex-site-Styles-headerLink" href="#Performance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            FastParse will never be able to compete with hand-written recursive descent parsers for speed. However, it's no slouch either; here's a comparison of FastParse with alternatives, using Parboiled2's JSON parsing benchmark, which parses a ~21,500 line JSON file:
</p>
        <table style="width: 100%;">
            <thead>
                <th>Benchmark</th><th>Score</th><th>Error</th></thead>
            <tbody>
                <tr>
                    <td>fastparse</td><td>80.536</td><td> 0.942</td></tr>
                <tr>
                    <td>fastparse-no-trace</td><td>89.873</td><td> 0.875</td></tr>
                <tr>
                    <td>argonaut</td><td>164.092</td><td> 2.869</td></tr>
                <tr>
                    <td>json4s-jackson</td><td>285.637</td><td> 3.954</td></tr>
                <tr>
                    <td>json4s-native</td><td>142.964</td><td> 2.076</td></tr>
                <tr>
                    <td>parboiled2</td><td>87.586</td><td> 1.176</td></tr>
                <tr>
                    <td>scala-parser-combinators</td><td>0.976</td><td> 0.018</td></tr>
                <tr>
                    <td>spray-json</td><td>189.784</td><td> 2.825</td>

</tr></tbody></table>
        <p>
            These numbers are the number of iterations/second of parsing a sample <code>test.json</code> file, averaged over 200 runs. As you can see, the FastParse based parser comes within a factor of 4 of the fastest hand written parser (Jackson), is just as fast as the Parboiled2 based parser (slightly faster/slower depending if full tracing is enabled), and is almost 100x faster than the scala-parser-combinators library.
</p>
        <p>
            In exchange for the perf hit compared to hand-rolled solutions, you get the <a href="#Json">short, super-simple parser definition</a>, and excellent error free error reporting. While for super-high-performance use cases you may still want a hand-rolled parser, for many ad-hoc situations a FastParse parser would do just fine. Remember, even at &quot;only&quot; 89 iterations per second that is still parsing 1,900,000 lines of JSON every second!
</p>
        <p>
            A similar speed ratio can be seen in parsing a <a href="https://github.com/scala-js/scala-js/blob/master/compiler/src/main/scala/org/scalajs/core/compiler/GenJSCode.scala">sample Scala file</a> using FastParse, Parboiled2 and Scalac's inbuilt hand-written Scala-language parser:
</p>
        <table style="width: 100%;">
            <thead>
                <th>Benchmark</th><th>Score</th><th>Error</th></thead>
            <tbody>
                <tr>
                    <td>fastparse</td><td>320.7</td><td>15.4</td></tr>
                <tr>
                    <td>fastparse-no-trace</td><td>434.7</td><td>23.4</td></tr>
                <tr>
                    <td>parboiled2</td><td>1354</td><td>7.97</td></tr>
                <tr>
                    <td>scalac</td><td>4888</td><td>113</td>
</tr></tbody></table>
        <p>
            These numbers are the number of iterations over 30 seconds, average of 4 runs, with 2 runs of warmup (discarded). FastParse performs worse here, at 11.5x slower than Scalac's in-built parser, and 3x slower than the equivalent Parboiled2-based parser. Depending on what you're doing, that may or may not be a problem: ScalaParse still makes progress at 57,027 lines of Scala per second, which despite being slower than the others is still blazing fast.
</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Internals" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Internals<a class=" scalatex-site-Styles-headerLink" href="#Internals" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            FastParse's internals are straightforward, at less than 1000 lines of code. Nonetheless, its design is unlike any other combinator library I've seen: externally immutable, pure-functional parser-combinators with mutable, highly-optimized internals.
</p>
        <h1 id="FastInterpreter" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FastInterpreter" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Fast Interpreter</h1>
            <p>
                FastParse is designed as a fast, immutable interpreter. That means</p>
            <ul>
                <li>
                    It does not do significant transformations of the grammar. The structure of the parser you define is the structure that will run. No transformation at compile time, no transformations at run-time.</li>
                <li>
                    It provides fast primitives like <a href="#CharsWhile">CharsWhile</a>, that you can drop in many places to speed up otherwise slow bulk operations (e.g. parsing whitespace, identifiers).</li>
                <li>
                    Error reported is straightforward: the last index that it does not backtrack out of is the index that is reported, and the parser at that point is the parser that is reported.
</li></ul>
            <p>
                In theory, it could be possible to perform either compile-time or initialization-time (before actually parsing) optimizations on the parser to improve performance. So far, I have not managed to find a scheme that has a significant improvement at an acceptable cost in terms of complexity. Apart from trivial de-sugarings (e.g. merging together <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(p1 | p2) | p3</code> into a single <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Either</code> node) what you write is what gets run
</p>
        <h1 id="ExternalImmutabiliy" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ExternalImmutabiliy" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>External Immutabiliy</h1>

            <p>
                FastParse presents a pure-functional, immutable external API to the user. That means that you can call <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]#parse</code> and not worry about having to set up neccessary state or instantiating objects. You take a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code>, call <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parse</code>, and get a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success[T]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code>
</p>
            <p>
                However, immutability poses a challenge: immutability usually involves lots of &quot;copy &amp; update&quot; operations rather than &quot;mutation&quot; operations, and on the JVM that means excessive garbage generation and collection. This is harmful for performance.
</p>
            <p>
                Thus FastParse performs some tricks internally to save allocations: the immutable <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Success</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Failure</code> result types are actually interfaces hiding <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Success</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Failure</code> implementations, which have entirely mutable fields.
</p>
            <p>
                This means that the same <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Success</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Failure</code> objects are shared throughout an entire parsing run, mutated as the parse progresses, while the external user only sees an immutable facade. This also means that a run of the large-and-complex <a href="#ScalaParse">ScalaParse</a> on a hundreds-of-kb source file results in exactly <i>three</i> allocations in all: one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Success</code>, one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Failure</code>, and one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Ctx</code> object holding them together.
</p>
        <h1 id="InternalOptimizations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#InternalOptimizations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Internal Optimizations</h1>
            <p>
                FastParse does some things that take advantage of the type-directed nature of the result-aggregation: while <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T].rep</code> returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[T]]</code> for an arbitrary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code>, there is a short circuit such that <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit].rep</code> simple returns <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit]</code>. This lets the common case of &quot;parsing things, not caring about the result&quot; avoid the allocation, while still allowing you to stick some other type in there (e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Any</code>) if you really do care about the bucket-of-<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Unit</code>s.
</p>
            <p>
                FastParse also takes advantage of the fact that <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>s are immutable. That makes it feasible to make instantiation mildly-expensive, since each one only gets instantiated once rather than per-parse. As an example, <a href="#CharIn">CharIn</a>, <a href="#CharPred">CharPred</a> and <a href="#CharsWhile">CharsWhile</a> all have their predicate converted to an identical bit-set to make character lookups extremely fast. Similarly, <a href="#StringIn">StringIn</a> gets converted into a Trie in order to allow one-pass matching of dozens of strings at the same time.</p>
            <p>
                These operations are not cheap: the bitsets easily take a few KB of memory each, and involve 65k iterations to fill them in. However, since <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>s are immutable, this one-time-cost goes from &quot;ridiculous&quot; to &quot;acceptable&quot;. All these internal optimizations are completely opaque to the user, who (apart from performance) never need to think about them.

</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Comparisons" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Comparisons<a class=" scalatex-site-Styles-headerLink" href="#Comparisons" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            FastParse differs from all other parser-combinator libraries in the Scala universe, in quite substantial ways:
</p>
        <ul>
            <li>
                Compared to <a href="https://github.com/sirthias/parboiled2">Parboiled2</a>, FastParse does not use macros to compile-time-generate fast parser code. Rather, it acts as an efficient interpreter, sacrificing some speed (1-4x slower) for huge amounts of usability. Parboiled2 in particular has <a href="https://groups.google.com/forum/#!msg/scala-internals/4N-uK5YOtKI/9vAdsH1VhqAJ">usability problems and bugs</a> that make it excruciating difficult to use, and also does not support higher-order rules. FastParse suffers from none of these problems.</li>
            <li>
                <a href="https://github.com/sirthias/parboiled/wiki">Parboiled1</a> is a Java library, and does not/cannot work on Scala.js</li>
            <li>
                <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a> is similar, but poorly executed. It is ~100x slower than FastParse, has an awkward inheritance-based API, and is full of bugs despite being half a decade old. FastParse is faster, has self-contained pure-functional parsers, and fixes bugs e.g. by having the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> operator actually work.
</li></ul></div>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ScalaParse" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">ScalaParse<a class=" scalatex-site-Styles-headerLink" href="#ScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">

    <div id="scaladiv"></div>
    <script>demo.DemoMain().scalaparser(document.getElementById("scaladiv"))</script>

    <p>
        ScalaParse is a parser for the entire Scala programming language, written using FastParse. This is notable for a few reasons:
</p>
    <ul>
        <li>
            ScalaParse is about 700 lines of code, making it about 1/10th the size of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
        <li>
            ScalaParse runs about <a href="#Performance">1/8th the speed</a> of of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
        <li>
            ScalaParse has excellent error reporting due to proper use of <a href="#Cuts">Cuts</a>, without any code explicitly dedicated to error reporting</li></ul>
    <p>
        ScalaParse does not currently generate an AST. As you can see, the parse result above is listed as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">undefined</code>. However, that does not make it useless! Even without generating an AST, ScalaParse can be used to:
</p>
    <ul>
        <li>
            Check for errors! ScalaParse provides excellent error reporting on parses, equal or better than that provided by the tools.nsc.Global parser, entirely for free.</li>
        <li>
            Prototype extensions to the Scala grammar! Unlike the default tools.nsc.Global parser, ScalaParse makes it trivial to add new rules at various sections of the grammar.</li>
        <li>
            Manipulate Scala code sections! It's trivial to wrap various rules in ScalaParse in an <a href="#Capture">Capture</a> and use it to pull out the relevant bits of a Scala file for you to use.

</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="UsingScalaParse" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Using ScalaParse<a class=" scalatex-site-Styles-headerLink" href="#UsingScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p></p>
        To begin using ScalaParse, add

        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;scalaparse&quot; % &quot;0.3.6&quot;
</code></pre>
        <p>
            To your SBT configuration. To use with Scala.js, you'll need
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;scalaparse&quot; % &quot;0.3.6&quot;
</code></pre></div>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ChangeLog" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Change Log<a class=" scalatex-site-Styles-headerLink" href="#ChangeLog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.3.6" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.3.6<a class=" scalatex-site-Styles-headerLink" href="#0.3.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Fix <b>#77</b>: deduplicate traceParsers in WhitespaceAPI to prevent stack overflow, by <a href="https://github.com/jeroenr">Jeroen Rosenberg</a></li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.3.5" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.3.5<a class=" scalatex-site-Styles-headerLink" href="#0.3.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Minor improvements to error-reporting in Scalaparse; error messages inside tuple-types and refinement-types should be slightly more precise</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.3.4" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.3.4<a class=" scalatex-site-Styles-headerLink" href="#0.3.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Fix <b>#69</b>: performance problem in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">StringsIn</code> parser, which resulted in initialization time exponential relative to the length of the longest string, by <a href="https://github.com/rklaehn">Rudiger Klaehn</a></li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.3.3" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.3.3<a class=" scalatex-site-Styles-headerLink" href="#0.3.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                <b>#66</b> Bugfix: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.rep</code> now handles max=0 properly, by <a href="https://github.com/ProjectZetta/">Martin Senne</a>
</li>
            <li>
                Further restructuring of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Result</code> by <a href="https://github.com/ProjectZetta/">Martin Senne</a>
                 <ul>
                     <li>
                         Object <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code> has been renamed to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>
                                </li>
                     <li>
                         Former <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code> has moved to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>.
                                </li>
                     <li>
                         Methods for position retrieval <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">line</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">col</code> have moved to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure.Extra</code>
</li></ul></li>
            <li>
                <b>#59</b> Fix <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.core.Result.Failure.formatParser()</code> throwing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">UnsupportedOperationException</code> on receiving an empty string as an input, by <a href="https://github.com/solar">solar</a></li>
            <li>
                <b>#61</b> Added the <a href="#Opaque">Opaque</a> combinator, which allows to provide more high-level error messages, by <a href="https://github.com/stanch">Nick Stanch</a></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure</code> has been restructured: Less-commonly-used properties like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">input</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">traced</code> have been aggregated into an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure.Extra</code> object, simplifying pattern matching. By <a href="https://github.com/ProjectZetta/">Martin Senne</a>
</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.3.2" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.3.2<a class=" scalatex-site-Styles-headerLink" href="#0.3.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Slightly better parsing of triple-quote strings in Scalaparse</li>
            <li>
                Added an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">type Result[T]</code> to match the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val Result</code> inside <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.all</code></li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.3.1" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.3.1<a class=" scalatex-site-Styles-headerLink" href="#0.3.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                <b>#47</b> Upgraded to Scala.js 0.6.5, removed unnecessary <code>CharPredicate</code>s</li>
            <li>
                <b>#42</b> Renamed <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~! b</code> to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~/ b</code> to avoid confusion with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~ !b</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code> objects now expose the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.line</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.col</code> attributes, in addition to the raw <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.index</code>, and display these in the default trace messages</li>
            <li>
                <b>#27</b> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> now can take a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">max</code> in addition to a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">min</code></li>
            <li>
                <b>#40</b> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> now properly displays the proper snippet of text when propagating failure upward</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.2.1" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.2.1<a class=" scalatex-site-Styles-headerLink" href="#0.2.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Simplified ScalaParse internals slightly</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser#get</code> now throws a custom <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">SyntaxError</code> with relevant metadata, instead of a plain <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Exception</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WhitespaceApi</code>'s <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WL</code> value no longer leaks out when you import from it</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.2.0" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.2.0<a class=" scalatex-site-Styles-headerLink" href="#0.2.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Default import changed from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse._</code> to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all._</code>, to make space for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi._</code></li>
            <li>
                Major changes to parser internals: the internal representation of parse results in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Mutable.{Success, Failure}</code> has been split off from the immutable external represenation <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.{Success, Failure}</code></li>
            <li>
                Error-reporting has been overhauled, and is greatly improved at the cost of being more expensive. Detailed errors now require a second parse with instrumentation</li>
            <li>
                The cheap &amp; spartan error data in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure</code> has been split out from the expensive but detailed error traces in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure#traced</code>.</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> now uses the parser's own <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.toString</code> by default if you don't pass in a tag, for convenience.</li>
            <li>
                Added the ability to exclude the default parser operators via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi._</code>, allowing you to import custom sets of operators tailored to your needs.</li>
            <li>
                Introduced the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.WhitespaceApi</code> class, which replaces the default set of operators with a new set which eagerly consumes whitespace between parsers.</li>
            <li>
                Updated ScalaParse to use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.WhitespaceApi</code>, resulting in much more precise error locations. Errors are now positioned before the characters which failed, rather than before the preceding whitespace, and syntax errors in comments now provide better errors</li>
            <li>
                Added unit tests and examples/demos of <a href="#WhitespaceHandling">Whitespace Handling</a> and <a href="#IndentationGrammars">Indentation Grammars</a></li>
            <li>
                Added <a href="#Filter">Filter</a> to the API, to complement <a href="#Map">Map</a> and <a href="#FlatMap">FlatMap</a></li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.1.7" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.1.7<a class=" scalatex-site-Styles-headerLink" href="#0.1.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                More fixes for ScalaParse, added more projects to test suite</li>
            <li>
                Auto-generate <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Sequencer</code> instances up to 22</li>
            <li>
                Removed unnecessary runtime utest dependency</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.1.6" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.1.6<a class=" scalatex-site-Styles-headerLink" href="#0.1.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Introduced five new projects into the test suite: ScalaIDE, GitBucket, Scalding, Scaloid, Marathon</li>
            <li>
                Fixed bug in ScalaParse around using function <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">=&gt;</code> types as type ascriptions</li>
            <li>
                Added ability to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">instrument</code> parsers, in order to gather out-of-band information about them e.g. for debugging or profiling</li>
            <li>
                Added <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase</code> combinator, for case-insensitive string matching</li>
            <li>
                Cross-published for Scala 2.10
</li></ul></div>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"FastParse 0.3.6","children":[{"value":"Getting Started","children":[]},{"value":"Writing Parsers","children":[{"value":"Basic","children":[{"value":"Sequence","children":[]},{"value":"Repeat","children":[]},{"value":"Optional","children":[]},{"value":"Either","children":[]},{"value":"End, Start","children":[]},{"value":"Pass, Fail","children":[]},{"value":"Index","children":[]},{"value":"Capture","children":[]},{"value":"AnyChar","children":[]},{"value":"Positive Lookahead","children":[]},{"value":"Negative Lookahead","children":[]},{"value":"Map","children":[]},{"value":"FlatMap","children":[]},{"value":"Filter","children":[]},{"value":"Opaque","children":[]},{"value":"Log","children":[]}]},{"value":"Intrinsics","children":[{"value":"CharPred","children":[]},{"value":"CharIn","children":[]},{"value":"CharsWhile","children":[]},{"value":"StringIn","children":[]}]},{"value":"Cuts","children":[{"value":"No Cuts","children":[]},{"value":"Cuts","children":[]},{"value":"Rep Cuts","children":[]},{"value":"Isolating Cuts","children":[]}]}]},{"value":"Example Parsers","children":[{"value":"Math","children":[]},{"value":"Whitespace Handling","children":[]},{"value":"Indentation Grammars","children":[]},{"value":"Json","children":[]},{"value":"PythonParse","children":[]}]},{"value":"API Highlights","children":[{"value":"Parser[T]","children":[]},{"value":"ParserApi[T]","children":[]},{"value":"Parsing Results","children":[]}]},{"value":"Debugging Parsers","children":[{"value":"Using Cuts","children":[]},{"value":"Using Log","children":[]},{"value":"Tracing","children":[]},{"value":"Use Cases","children":[]}]},{"value":"Performance","children":[]},{"value":"Internals","children":[{"value":"Fast Interpreter","children":[]},{"value":"External Immutabiliy","children":[]},{"value":"Internal Optimizations","children":[]}]},{"value":"Comparisons","children":[]}]},{"value":"ScalaParse","children":[{"value":"Using ScalaParse","children":[]}]},{"value":"Change Log","children":[{"value":"0.3.6","children":[]},{"value":"0.3.5","children":[]},{"value":"0.3.4","children":[]},{"value":"0.3.3","children":[]},{"value":"0.3.2","children":[]},{"value":"0.3.1","children":[]},{"value":"0.2.1","children":[]},{"value":"0.2.0","children":[]},{"value":"0.1.7","children":[]},{"value":"0.1.6","children":[]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              