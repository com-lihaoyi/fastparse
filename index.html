<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>FastParse 3.0.0</title><script src="scripts.js"></script></head><body><div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27464920-6', 'auto');
  ga('send', 'pageview');

</script>
<a href="https://github.com/lihaoyi/fastparse" style="position: absolute;top: 0px;right: 0px;border: 0;"><img src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FastParse3.0.0" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FastParse 3.0.0<a class=" scalatex-site-Styles-headerLink" href="#FastParse3.0.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /><h2 style="font-weight: 300;color: #ccc;padding: 0px;margin-top: 0px;">Fast to write, Fast running Parsers in Scala</h2></div><div class=" scalatex-site-Styles-content">
    

<pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse._, NoWhitespace._
def number[$: P]: P[Int] = P( CharIn(&quot;0-9&quot;).rep(1).!.map(_.toInt) )
def parens[$: P]: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
def factor[$: P]: P[Int] = P( number | parens )

def divMul[$: P]: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
def addSub[$: P]: P[Int] = P( divMul ~ (CharIn(&quot;+\\-&quot;).! ~/ divMul).rep ).map(eval)
def expr[$: P]: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L20-L29" target="_blank"><i class="fa fa-link "></i></a></pre>
<pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success(2, _) = parse(&quot;1+1&quot;, expr(_))
val Parsed.Success(15, _) = parse(&quot;(1+1*2)+3*4&quot;, expr(_))
val Parsed.Success(21, _) = parse(&quot;((1+1*2)+(3*4*5))/3&quot;, expr(_))
val Parsed.Failure(expected, failIndex, extra) = parse(&quot;1+1*&quot;, expr(_))
val longAggMsg = extra.trace().longAggregateMsg
assert(
  failIndex == 4,
  longAggMsg ==
  &quot;&quot;&quot;Expected expr:1:1 / addSub:1:1 / divMul:1:3 / factor:1:5 / (number | parens):1:5, found &quot;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L31-L41" target="_blank"><i class="fa fa-link "></i></a></pre>
<div id="splashdiv"></div>
<script>DemoMain.math(document.getElementById("splashdiv"))</script>
<p>
    FastParse is a Scala library for parsing strings and bytes into structured
    data. This lets you easily write a parser for any arbitrary textual data
    formats (e.g. program source code, JSON, ...) and have the parsers run at
    an acceptable speed, with great error debuggability and error reporting.
    Features include:
</p>
<ul>
    <li>
        <a href="#Performance">Comparable in speed to a hand-written parser</a>,
        200x faster than <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a></li>
    <li>
        1/10th the size of a hand-written parser</li>
    <li>
        Automatic, excellent <a href="#DebuggingParsers">error-reporting and diagnostics</a>.</li>
    <li>
        <a href="#StreamingParsing">Streaming Parsing</a> of data-sets to avoid pre-loading
        everything into memory</li>
    <li>
        Compatible with both Scala-JVM and Scala.js
</li></ul>
<p>
    This documentation serves as a thorough reference on how to use this library.
    For a more hands-on introduction, take a look at the following blog post:
</p>
<ul>
    <li>
        <a href="http://www.lihaoyi.com/post/EasyParsingwithParserCombinators.html">Easy Parsing with Parser Combinators</a>
</li></ul>
<p>
    FastParse is a project by <a href="http://www.lihaoyi.com/">Li Haoyi</a>. If
    you use FastParse and enjoyed it, please chip in to support our development
    at <a href="https://www.patreon.com/lihaoyi">https://www.patreon.com/lihaoyi</a>.
    </p>
<p>
    The following sections will introduce you to FastParse and how to use it.
</p>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="GettingStarted" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Getting Started<a class=" scalatex-site-Styles-headerLink" href="#GettingStarted" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        To begin using FastParse, add the following to your build config
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;fastparse&quot; % &quot;2.2.2&quot; // SBT
ivy&quot;com.lihaoyi::fastparse:2.2.2&quot; // Mill
</code></pre>
    <p>
        To use with Scala.js, you'll need</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;fastparse&quot; % &quot;2.2.2&quot; // SBT
ivy&quot;com.lihaoyi::fastparse::2.2.2&quot; // Mill
</code></pre>


    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="WritingParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Writing Parsers<a class=" scalatex-site-Styles-headerLink" href="#WritingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="Basic" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Basic" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Basic</h1>
        <p>
            The simplest parser matches a single string:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse._, NoWhitespace._
def parseA[$: P] = P(&quot;a&quot;)

val Parsed.Success(value, successIndex) = parse(&quot;a&quot;, parseA(_))
assert(value == (), successIndex == 1)

val f @ Parsed.Failure(label, index, extra) = parse(&quot;b&quot;, parseA(_))
assert(
  label == &quot;&quot;,
  index == 0,
  f.msg == &quot;&quot;&quot;Position 1:1, found &quot;b&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L14-L26" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Such a parser returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> if the input matches the string, and otherwise returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code>.</p>
        <p>
            As you can see, by default the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> contains
            a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(): Unit</code>, unless you use <a href="#Capture">Capture</a> or
            <a href="#Map">Map</a> described below.
</p>
        <p>
            You can also wrap the strings in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase(&quot;...&quot;)</code> if you want the matching to be case-insensitive.
</p>
        <p>
            The <code>P(...)</code> lets you write mutually recursive parsers, without
            running into circular initialization problems, and gives the parser a
            nice, human-readable name (from the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def</code>
            it is being assigned to) which appears in parse error messages.
            In general, every time you assign a parser
            to a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def</code>, you should wrap it in <code>P(...)</code>.</p>
        <p>
            You can also call <code>fastparse.parse</code> on any
            <a href="https://github.com/lihaoyi/geny#readable">geny.Readable</a> value,
            such as <code>Array[Byte]</code>s to parse binary data, or <code>java.io.InputStream</code>s
            for streaming parsing.
</p>
        <h2 id="Failures" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Failures" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Failures</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse._, NoWhitespace._
def parseEither[$: P] = P( &quot;a&quot; | &quot;b&quot; )
def parseA[$: P] = P( parseEither.? ~ &quot;c&quot; )
val f @ Parsed.Failure(failureString, index, extra) = parse(&quot;d&quot;, parseA(_))

assert(
  failureString == &quot;&quot;,
  index == 0,
  f.msg == &quot;&quot;&quot;Position 1:1, found &quot;d&quot;&quot;&quot;&quot;
)

// .trace() collects additional metadata to use for error reporting
val trace = f.trace()

// `.msg` records the last parser that failed, which is &quot;c&quot;, and
// `.longMsg` also shows the parsing stack at point of failure
assert(
  trace.label == &quot;\&quot;c\&quot;&quot;,
  trace.index == 0,
  trace.msg == &quot;&quot;&quot;Expected &quot;c&quot;:1:1, found &quot;d&quot;&quot;&quot;&quot;,
  trace.longMsg == &quot;&quot;&quot;Expected parseA:1:1 / &quot;c&quot;:1:1, found &quot;d&quot;&quot;&quot;&quot;
)

// aggregateMsg and longAggregateMsg record all parsers
// failing at the position, &quot;a&quot; | &quot;b&quot; | &quot;c&quot;,


assert(
  trace.aggregateMsg == &quot;&quot;&quot;Expected (parseEither | &quot;c&quot;):1:1, found &quot;d&quot;&quot;&quot;&quot;,
  trace.longAggregateMsg == &quot;&quot;&quot;Expected parseA:1:1 / (parseEither | &quot;c&quot;):1:1, found &quot;d&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L29-L60" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                When parsing, dealing with failures is an important part of
                making things work. Fastparse provides three levels of error
                reporting you can ask for when a parse fails:</p>
            <ol>
                <li>
                    The default <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code> only tells you the
                    position of the error message, without any clues what went
                    wrong at that position.</li>
                <li>
                    You can pass in the flag <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">verboseFailures = true</code>
                    to <code>fastparse.parse</code> to get a better description of what
                    caused the parse failure. This slows the parse down by a
                    significant amount (takes ~50% longer than a normal parse),
                    You can then use the <code>.msg</code> or <code>.longMsg</code> to see
                    what's going on.</li>
                <li>
                    You can call <code>failure.trace()</code> on an existing failure
                    to perform a second parse over the initial input. This also
                    gives you access to <code>failure.trace().msg</code> and
                    <code>failure.trace().longMsg</code>, but additionally provides
                    <code>.aggregateMsg</code> and <code>.longAggregateMsg</code> for
                    high-level listing of what was expected at point of failure,
                    or <code>.terminalsMsg</code> and <code>.longTerminalsMsg</code> for a
                    low-level view of what individual strings or characters
                    were expected at point of failure.
</li></ol>
            <p>
                In general, you may either want to run your parses with
                <code>verboseFailures</code> enabled, or run in the default fast mode
                and fall back to <code>.trace()</code> when
                something goes wrong. Often the number of parse failures is
                small compared to the number of successes, and this approach
                ensures the common success case is as fast as possible.
</p>
        <h2 id="Sequence" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Sequence" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Sequence</h2>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def ab[$: P] = P( &quot;a&quot; ~ &quot;b&quot; )

val Parsed.Success(_, 2) = parse(&quot;ab&quot;, ab(_))

val Parsed.Failure(_, 1, _) = parse(&quot;aa&quot;, ab(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L63-L68" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                You can combine two parsers with the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code> operator. This creates a new parser that only succeeds if both left and right parsers succeed one after another.
</p>
        <h2 id="Repeat" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Repeat" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Repeat</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def ab[$: P] = P( &quot;a&quot;.rep ~ &quot;b&quot; )
val Parsed.Success(_, 8) = parse(&quot;aaaaaaab&quot;, ab(_))
val Parsed.Success(_, 4) = parse(&quot;aaaba&quot;, ab(_))

def abc[$: P] = P( &quot;a&quot;.rep(sep=&quot;b&quot;) ~ &quot;c&quot;)
val Parsed.Success(_, 8) = parse(&quot;abababac&quot;, abc(_))
val Parsed.Failure(_, 3, _) = parse(&quot;abaabac&quot;, abc(_))

def ab4[$: P] = P( &quot;a&quot;.rep(min=2, max=4, sep=&quot;b&quot;) )
val Parsed.Success(_, 7) = parse(&quot;ababababababa&quot;, ab4(_))

def ab2exactly[$: P] = P( &quot;ab&quot;.rep(exactly=2) )
val Parsed.Success(_, 4) = parse(&quot;abab&quot;, ab2exactly(_))

def ab4c[$: P] = P ( &quot;a&quot;.rep(min=2, max=4, sep=&quot;b&quot;) ~ &quot;c&quot; )
val Parsed.Failure(_, 1, _) = parse(&quot;ac&quot;, ab4c(_))
val Parsed.Success(_, 4) = parse(&quot;abac&quot;, ab4c(_))
val Parsed.Success(_, 8) = parse(&quot;abababac&quot;, ab4c(_))
val Parsed.Failure(_, 7, _) = parse(&quot;ababababac&quot;, ab4c(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L71-L90" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> method creates a new parser that attempts to parse the given parser zero or more times.
                If you want to parse something a given number of times, you can use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(min = 2, max = 4)</code> o
                r the shorter <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(1)</code> for one or more times,
                in addition there is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">exactly</code> parameter that if it's defined behaves
                like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">min</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">max</code> equals to it.
                You can optionally provide an argument which acts as a separator between the usages of the original parser,
                such as a comma in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(sep = &quot;,&quot;)</code>.
</p>
        <h2 id="Optional" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Optional" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Optional</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def option[$: P] = P( &quot;c&quot;.? ~ &quot;a&quot;.rep(sep=&quot;b&quot;).! ~ End)

val Parsed.Success(&quot;aba&quot;, 3) = parse(&quot;aba&quot;, option(_))
val Parsed.Success(&quot;aba&quot;, 4) = parse(&quot;caba&quot;, option(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L93-L97" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Similar to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>, which creates a new parser that attempts to parse the given parser zero or 1 times.
</p>
        <h2 id="Either" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Either" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Either</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def either[$: P] = P( &quot;a&quot;.rep ~ (&quot;b&quot; | &quot;c&quot; | &quot;d&quot;) ~ End)

val Parsed.Success(_, 6) = parse(&quot;aaaaab&quot;, either(_))
val f @ Parsed.Failure(_, 5, _) = parse(&quot;aaaaae&quot;, either(_))
val trace = f.trace().longAggregateMsg
assert(
  f.toString == &quot;&quot;&quot;Parsed.Failure(Position 1:6, found &quot;e&quot;)&quot;&quot;&quot;,
  trace == &quot;&quot;&quot;Expected either:1:1 / (&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;):1:6, found &quot;e&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L100-L109" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code> operator tries the parser on the left, and if that fails, tries the one on the right, failing only if both parsers fail.
</p>
        <h2 id="End,Start" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#End,Start" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>End, Start</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def noEnd[$: P] = P( &quot;a&quot;.rep ~ &quot;b&quot;)
def withEnd[$: P] = P( &quot;a&quot;.rep ~ &quot;b&quot; ~ End)

val Parsed.Success(_, 4) = parse(&quot;aaaba&quot;, noEnd(_))
val Parsed.Failure(_, 4, _) = parse(&quot;aaaba&quot;, withEnd(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L112-L117" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code> parser only succeeds if at the end of the input string. By default, a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code> does not need to consume the whole input, and can succeed early consuming a portion of it (exactly how much input was consumed is stored in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#index</code> attribute). By using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code>, we can make the parse fail if it doesn't consume everything
</p>
            <p>
                There is also a similar <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Start</code> parser, which only succeeds at the start of the input</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def ab[$: P] = P( ((&quot;a&quot; | Start) ~ &quot;b&quot;).rep ~ End).!

val Parsed.Success(&quot;abab&quot;, 4) = parse(&quot;abab&quot;, ab(_))
val Parsed.Success(&quot;babab&quot;, 5) = parse(&quot;babab&quot;, ab(_))

val Parsed.Failure(_, 2, _) = parse(&quot;abb&quot;, ab(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L120-L126" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="Pass,Fail" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Pass,Fail" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Pass, Fail</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success((), 0) = parse(&quot;asdad&quot;, Pass(_))
val Parsed.Failure(_, 0, _) = parse(&quot;asdad&quot;, Fail(_))

def failWithLabel[$: P] = P( Fail(&quot;custom fail msg&quot;) )
val Parsed.Failure(_, 0, extra) = parse(&quot;asdad&quot;, failWithLabel(_))
assert(extra.trace().longMsg == &quot;&quot;&quot;Expected failWithLabel:1:1 / fail:1:1, found &quot;asdad&quot;&quot;&quot;&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L129-L135" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                These two parsers always succeed, or always fail, respectively. Neither consumes any input.
</p>
        <h2 id="Index" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Index" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Index</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def finder[$: P] = P( &quot;hay&quot;.rep ~ Index ~ &quot;needle&quot; ~ &quot;hay&quot;.rep )

val Parsed.Success(9, _) = parse(&quot;hayhayhayneedlehay&quot;, finder(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L138-L141" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Always succeeds, and provides the current index of the parse into the input string. e.g. useful for providing source locations for AST nodes. Consumes no input.
</p>
        <h2 id="Capture" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Capture" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Capture</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def capture1[$: P] = P( &quot;a&quot;.rep.! ~ &quot;b&quot; ~ End)

val Parsed.Success(&quot;aaa&quot;, 4) = parse(&quot;aaab&quot;, capture1(_))

def capture2[$: P] = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;), 4) = parse(&quot;aaab&quot;, capture2(_))

def capture3[$: P] = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ &quot;c&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;, &quot;c&quot;), 5) = parse(&quot;aaabc&quot;, capture3(_))

def captureRep[$: P] = P( &quot;a&quot;.!.rep ~ &quot;b&quot; ~ End)

val Parsed.Success(Seq(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;), 4) = parse(&quot;aaab&quot;, captureRep(_))

def captureOpt[$: P] = P( &quot;a&quot;.rep ~ &quot;b&quot;.!.? ~ End)

val Parsed.Success(Some(&quot;b&quot;), 4) = parse(&quot;aaab&quot;, captureOpt(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L144-L163" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                So far, all the parsers go over the input text but do not return any useful value: the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#value</code> attribute was always <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">()</code>. In order to make them do so, you use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code> operation to capture the section of the input string the parser parsed.</p>
            <p>
                Note the types of each parser:</p>
            <ul>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture1</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[String]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture2</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[(String, String)]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture3</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[(String, String, String)]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureRep</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Seq[String]]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureOpt</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Option[String]]</code></li></ul>
            <p>
                In general, if you have a parser of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN</code>,
                capturing one more section turns it into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN+1</code>.
                Furthermore, if you capture within a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> or
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code> optional parser, it becomes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Seq[T]]</code>
                or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Option[T]]</code> respectively
</p>
        <h2 id="AnyChar" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AnyChar" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>AnyChar</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def ab[$: P] = P( &quot;'&quot; ~ AnyChar.! ~ &quot;'&quot; )

val Parsed.Success(&quot;-&quot;, 3) = parse(&quot;'-'&quot;, ab(_))

val Parsed.Failure(stack, 2, _) = parse(&quot;'-='&quot;, ab(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L166-L171" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This parser parses any single character successfully. It almost
                always succeeds, except if there simply aren't any characters left
                to parse.
</p>
            <p>
                There is also a plural <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyChars(count: Int)</code> version that
                parses exactly <code>count</code> characters in a row, regardless of
                what they are.
</p>
        <h2 id="PositiveLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PositiveLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Positive Lookahead</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def keyword[$: P] = P( (&quot;hello&quot; ~ &amp;(&quot; &quot;)).!.rep )

val Parsed.Success(Seq(&quot;hello&quot;), _) = parse(&quot;hello &quot;, keyword(_))
val Parsed.Success(Seq(), _) = parse(&quot;hello&quot;, keyword(_))
val Parsed.Success(Seq(), _) = parse(&quot;helloX&quot;, keyword(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L175-L180" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&amp;(...)</code> operator wraps a parser, only succeeds if it succeeds, but consumes no input. Useful for doing checks like &quot;these characters must be followed by a whitespace, but don't consume the whitespace&quot;
</p>
        <h2 id="NegativeLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NegativeLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Negative Lookahead</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def keyword[$: P] = P( &quot;hello&quot; ~ !&quot; &quot; ~ AnyChar ~ &quot;world&quot; ).!

val Parsed.Success(&quot;hello-world&quot;, _) = parse(&quot;hello-world&quot;, keyword(_))
val Parsed.Success(&quot;hello_world&quot;, _) = parse(&quot;hello_world&quot;, keyword(_))

val Parsed.Failure(_, 5, _) = parse(&quot;hello world&quot;, keyword(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L183-L189" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">!...</code> operator wraps a parser and only succeeds if it fails, also consuming no input. Useful to combine with other parsers like <a href="#AnyChar">AnyChar</a> to restrict the things that they can parse.</p>
        <h2 id="Map" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Map" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Map</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def binary[$: P] = P( (&quot;0&quot; | &quot;1&quot; ).rep.! )
def binaryNum[$: P] = P( binary.map(Integer.parseInt(_, 2)) )

val Parsed.Success(&quot;1100&quot;, _) = parse(&quot;1100&quot;, binary(_))
val Parsed.Success(12, _) = parse(&quot;1100&quot;, binaryNum(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L193-L198" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Up till now, we've only dealt with</p>
            <ul>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Unit]</code>: the default case</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[String]</code>: after capturing something with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[TupleN[String]]</code>: capturing multiple things in series</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Seq[String]]</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Option[String]]</code>: capturing
                    things in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>
</li></ul>
            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> lets you convert an arbitrary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[T]</code> into a
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[V]</code> by providing a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; V</code> function. This is
                useful for converting the strings and tuples/seqs/options of strings
                into more useful data-structures.</p>
        <h2 id="FlatMap" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FlatMap" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>FlatMap</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def leftTag[$: P] = P( &quot;&lt;&quot; ~ (!&quot;&gt;&quot; ~ AnyChar).rep(1).! ~ &quot;&gt;&quot;)
def rightTag[$: P](s: String) = P( &quot;&lt;/&quot; ~ s.! ~ &quot;&gt;&quot; )
def xml[$: P] = P( leftTag.flatMap(rightTag(_)) )

val Parsed.Success(&quot;a&quot;, _) = parse(&quot;&lt;a&gt;&lt;/a&gt;&quot;, xml(_))
val Parsed.Success(&quot;abcde&quot;, _) = parse(&quot;&lt;abcde&gt;&lt;/abcde&gt;&quot;, xml(_))

val failure = parse(&quot;&lt;abcde&gt;&lt;/edcba&gt;&quot;, xml(_)).asInstanceOf[Parsed.Failure]
assert(
  failure.trace().longAggregateMsg == &quot;&quot;&quot;Expected xml:1:1 / rightTag:1:8 / &quot;abcde&quot;:1:10, found &quot;edcba&gt;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L209-L220" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> allows you to dynamically choose a parser to continue with, given the result of the current parser. The example above uses it to parse balanced XML tags. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> can be used to parse indentation-based grammars, and is used to do so in <a href="http://lihaoyi.github.io/Scalatex/">Scalatex</a>.
</p>
            <p>
                Note that the function given to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> is evaluated every time this parser is tried. You should be conscious of the cost of re-creating the resultant parser every time, since FastParse parsers are somewhat expensive to initialize despite being fast per-run. If possible, store the parsers somewhere before-hand or memo-ize/cache them to avoid initializing them wastefully.</p>
            <p>
                As is normal in Scala, you can replace a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> call with a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">for</code>-comprehension, as below:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def leftTag[$: P] = P( &quot;&lt;&quot; ~ (!&quot;&gt;&quot; ~ AnyChar).rep(1).! ~ &quot;&gt;&quot; )
def rightTag[$: P](s: String) = P( &quot;&lt;/&quot; ~ s.! ~ &quot;&gt;&quot; )
def xml[$: P] = P(
  for{
    s &lt;- leftTag
    right &lt;- rightTag(s)
  } yield right
)

val Parsed.Success(&quot;a&quot;, _) = parse(&quot;&lt;a&gt;&lt;/a&gt;&quot;, xml(_))
val Parsed.Success(&quot;abcde&quot;, _) = parse(&quot;&lt;abcde&gt;&lt;/abcde&gt;&quot;, xml(_))

val failure = parse(&quot;&lt;abcde&gt;&lt;/edcba&gt;&quot;, xml(_)).asInstanceOf[Parsed.Failure]
assert(
  failure.trace().longAggregateMsg == &quot;&quot;&quot;Expected xml:1:1 / rightTag:1:8 / &quot;abcde&quot;:1:10, found &quot;edcba&gt;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L222-L238" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Which is equivalent and behaves exactly the same.
</p>
            <p>
                Note that <code>.flatMap</code> consumes whitespace between the first
                and second parsers; in cases where you do not want to do this,
                use <code>.flatMapX</code>
</p>
        <h2 id="Filter" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Filter" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Filter</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def digits[$: P] = P(CharPred(c =&gt; '0' &lt;= c &amp;&amp; c &lt;= '9').rep(1).!).map(_.toInt)
def even[$: P] = P( digits.filter(_ % 2 == 0) )
val Parsed.Success(12, _) = parse(&quot;12&quot;, even(_))
val failure = parse(&quot;123&quot;, even(_)).asInstanceOf[Parsed.Failure]</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L240-L244" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> allows you to supply a predicate
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; Boolean</code> which is applied to the successful
                result of the current parser. If the predicate is true the
                filtered parser succeeds otherwise it fails. The example
                above uses <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> on digits to parse only even
                numbers successfully while odd numbers will fail. If the
                current parser fails then that failure is simply passed along.
</p>
        <h2 id="Opaque" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Opaque" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Opaque</h2>
            <p>
                Sometimes it's useful to hide parser's implementation details
                and provide a higher-level error message. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.opaque</code>
                achieves exactly that.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def digit[$: P] = CharIn(&quot;0-9&quot;)
def letter[$: P] = CharIn(&quot;A-Z&quot;)
def twice[T, $: P](p: =&gt; P[T]) = p ~ p
def errorMessage[T](p: P[_] =&gt; P[T], str: String) =
  parse(str, p).asInstanceOf[Parsed.Failure].trace().longAggregateMsg

// Portuguese number plate format since 2006
def numberPlate[$: P] = P(twice(digit) ~ &quot;-&quot; ~ twice(letter) ~ &quot;-&quot; ~ twice(digit))

val err1 = errorMessage(numberPlate(_), &quot;11-A1-22&quot;)
assert(err1 == &quot;&quot;&quot;Expected numberPlate:1:1 / [A-Z]:1:5, found &quot;1-22&quot;&quot;&quot;&quot;)

// Suppress implementation details from the error message
def opaqueNumberPlate[$: P] = numberPlate.opaque(&quot;&lt;number-plate&gt;&quot;)

val err2 = errorMessage(opaqueNumberPlate(_), &quot;11-A1-22&quot;)
assert(err2 == &quot;&quot;&quot;Expected &lt;number-plate&gt;:1:1, found &quot;11-A1-22&quot;&quot;&quot;&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L246-L263" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Parsers marked as <code>.opaque</code> only succeed or fail as a
                single entity and leaves no traces of underlying parsers on
                the stack.
</p>
        <h2 id="Log" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Log" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Log</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val logged = collection.mutable.Buffer.empty[String]
implicit val logger = Logger(logged.append(_))

def DeepFailure[$: P] = P( &quot;C&quot; ).log
def Foo[$: P] = P( (DeepFailure | &quot;A&quot;) ~ &quot;B&quot;.!).log

parse(&quot;AB&quot;, Foo(_))

val allLogged = logged.mkString(&quot;\n&quot;)

val expected =
  &quot;&quot;&quot;+Foo:1:1, cut
    |  +DeepFailure:1:1
    |  -DeepFailure:1:1:Failure(DeepFailure:1:1 / &quot;C&quot;:1:1 ...&quot;AB&quot;)
    |-Foo:1:1:Success(1:3, cut)
    |
&quot;&quot;&quot;.stripMargin.trim
assert(allLogged == expected)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L469-L487" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <a href="#DebuggingParsers">Debugging Parsers</a> is often done with the
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> method, which logs output whenever the
                parser is tried, and when it succeeds or fails, together with
                the location and other data when these things happen (traces
                on failures, results on successes, the presence of
                <a href="#Cuts">Cuts</a>, ...). You can define custom loggers as we've
                done here, or you can just leave it to by default print to stdout.
</p>
            <p>
                Generally, if a parser is doing something wrong, the workflow is:
</p>
            <ul>
                <li>
                    Add a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> to the parser which is misbehaving</li>
                <li>
                    See where it's being tried, and what it's result
                    (success/failure) is, and confirm that it is misbehaving.</li>
                <li>
                    Look at the parsers it's made of; which one of them is
                    misbehaving and causing the larger parser to misbehave?</li>
                <li>
                    Add <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code>s to all of them</li>
                <li>
                    Identify which of the sub-parsers is misbehaving</li>
                <li>
                    Repeat</li></ul>
            <p>
                It's a non-trivial process, but it is generally not hard to
                figure out what's happening this way.
</p>
    <h1 id="Utilities" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Utilities" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Utilities</h1>
        <p>
            Fastparse provides tools for many common use cases, so you do not
            need to implement them yourself. These utilities are optimized and
            likely faster than whatever you would come up with on the spot, so
            you should use them whenever possible
</p>
        <h2 id="CharPred" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharPred" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharPred</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def cp[$: P] = P( CharPred(_.isUpper).rep.! ~ &quot;.&quot; ~ End )

val Parsed.Success(&quot;ABC&quot;, _) = parse(&quot;ABC.&quot;, cp(_))
val Parsed.Failure(_, 2, _) = parse(&quot;ABc.&quot;, cp(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L268-L272" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharPred</code> takes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char =&gt; Boolean</code>
                predicate and creates a parser that parses any single character
                that satisfies that predicate. e.g. you can use any of the
                helpful methods on <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">scala.Char</code> to check if a
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char</code> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isUpper</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isDigit</code>,
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isControl</code>, etc. etc.
</p>
        <h2 id="CharIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharIn</h2>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def ci[$: P] = P( CharIn(&quot;abc&quot;, &quot;xyz&quot;).rep.! ~ End )

val Parsed.Success(&quot;aaabbccxyz&quot;, _) = parse(&quot;aaabbccxyz&quot;, ci(_))
val Parsed.Failure(_, 7, _) = parse(&quot;aaabbccdxyz.&quot;, ci(_))


def digits[$: P] = P( CharIn(&quot;0-9&quot;).rep.! )

val Parsed.Success(&quot;12345&quot;, _) = parse(&quot;12345abcde&quot;, digits(_))
val Parsed.Success(&quot;123&quot;, _) = parse(&quot;123abcde45&quot;, digits(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L275-L285" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Similar to <a href="#CharPred">CharPred</a>, except you pass in literal
                strings containing regex-style character ranges. This could
                be things like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;abcd&quot;</code> to accept the first four
                alphabets, or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;a-zA-Z&quot;</code> to accept all alphabets
                both lower and uppercase. Since the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;-&quot;</code> character
                is used to express character ranges, it needs to be escaped
                if you want to match it directly e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;+\\-&quot;</code>
                to match either <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;+&quot;</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;-&quot;</code>. The
                backslash character also needs to be similarly escaped
                e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;\\\\&quot;</code> to match a single backslash
</p>
        <h2 id="CharsWhile" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharsWhile" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharsWhile</h2>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def cw[$: P] = P( CharsWhile(_ != ' ').! )

val Parsed.Success(&quot;12345&quot;, _) = parse(&quot;12345&quot;, cw(_))
val Parsed.Success(&quot;123&quot;, _) = parse(&quot;123 45&quot;, cw(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L288-L292" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                A repeated version of <a href="#CharPred">CharPred</a>: this parser
                continually chomps away at characters as long as they continue
                passes the given predicate.
</p>
            <p>
                This is a very fast parser, ideal for quickly consuming large
                numbers of characters.
</p>
        <h2 id="CharsWhileIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharsWhileIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharsWhileIn</h2>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def cw[$: P] = P( CharsWhileIn(&quot;123456789&quot;).! )

val Parsed.Success(&quot;12345&quot;, _) = parse(&quot;12345&quot;, cw(_))
val Parsed.Success(&quot;123&quot;, _) = parse(&quot;123 45&quot;, cw(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L294-L298" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                A combination of <a href="#CharsWhile">CharsWhile</a> and <a href="#CharIn">CharIn</a>, this
                parser continues consuming characters as long as they are within
                the set you characters you passed to it. Like <a href="#CharIn">CharIn</a>,
                this parser takes in literal strings representing regex-style
                character ranges that it accepts
</p>
        <h2 id="StringIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StringIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>StringIn</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def si[$: P] = P( StringIn(&quot;cow&quot;, &quot;cattle&quot;).!.rep(1) )

val Parsed.Success(Seq(&quot;cow&quot;, &quot;cattle&quot;), _) = parse(&quot;cowcattle&quot;, si(_))
val Parsed.Success(Seq(&quot;cow&quot;), _) = parse(&quot;cowmoo&quot;, si(_))
val Parsed.Failure(_, _, _) = parse(&quot;co&quot;, si(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L301-L306" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Quickly parses one of any number of strings that you give it.
                Behind the scenes, it converts the list of strings into a Trie
                so it can attempt to parse all of them in a single pass.
</p>
            <p>
                As a result, this is much faster to execute than if you had
                combined the individual strings with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;cow&quot; | &quot;cattle&quot; | ...</code>.
</p>
            <p>
                There is also a <code>StringInIgnoreCase</code> parser you can use
                if you want to match things case-insensitively.</p>
    <h1 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h1>
        <p>
            A &quot;cut&quot; (<code>a ~/ b</code> or <code>a./</code> in Fastparse) is a marker in a
            recursive-descent parser that states &quot;you cannot backtrack past this
            point&quot;. In FastParse, this serves two purposes:
</p>
        <ul>
            <li>
                Improving the quality of error-reporting while
                <a href="#DebuggingParsers">Debugging Parsers</a>: whether it's the parser that's
                incorrect or the input that's incorrect, the improved error
                messages due to Cuts makes it easier to figure out what's wrong</li>
            <li>
                Allowing <a href="#StreamingParsing">Streaming Parsing</a>: Even when parsing
                streaming input, FastParse parsers have to buffer the input
                in-memory in case the parser needs to backtrack, but adding
                Cuts tells the parser it can safely drop earlier parts of the
                input it can no longer backtrack to.
</li></ul>
        <h2 id="NoCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NoCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>No Cuts</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def alpha[$: P] = P( CharIn(&quot;a-z&quot;) )
def nocut[$: P] = P( &quot;val &quot; ~ alpha.rep(1).! | &quot;def &quot; ~ alpha.rep(1).!)

val Parsed.Success(&quot;abcd&quot;, _) = parse(&quot;val abcd&quot;, nocut(_))

val failure = parse(&quot;val 1234&quot;, nocut(_)).asInstanceOf[Parsed.Failure]
val trace = failure.trace().longAggregateMsg
assert(
  failure.index == 0,
  trace == &quot;&quot;&quot;Expected nocut:1:1 / (&quot;val &quot; ~ alpha.rep(1) | &quot;def &quot;):1:1, found &quot;val 1234&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L311-L322" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Above we have a naive scala definition parser: it either parses a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def</code>, a space, and its (lower-case only) name. On a success this works as expected, and extracts the name. However, on a failure, something odd happens: the deepest parser on-failure is shown to be the entire <a href="#Either">Either</a>, rather than just the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">alpha</code> that came after <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>. Why is that?
</p>
            <p>
                By default, the parse has an opportunity to backtrack whenever it enters a
</p>
            <ul>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>: If <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> fails, it tries <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>
</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.rep</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.?</code>: If parsing with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p</code> fails, it backtracks out of the failed parse and tries to parse whatever comes after the repeat/optional.</li></ul>
            <p>
                e.g. in the case of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>, if it tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> and fails, it then tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>. If <i>that</i> fails, all that FastParse knows is that one of them should have succeeded. Specifically, FastParse does <i>not</i> know that after successfully parsing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>, that only the left branch of the <a href="#Either">Either</a> is viable! Thus it has no choice but to offer both alternatives in the error message.
</p>
        <h2 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def alpha[$: P] = P( CharIn(&quot;a-z&quot;) )
def nocut[$: P] = P( &quot;val &quot; ~/ alpha.rep(1).! | &quot;def &quot; ~/ alpha.rep(1).!)

val Parsed.Success(&quot;abcd&quot;, _) = parse(&quot;val abcd&quot;, nocut(_))

val failure = parse(&quot;val 1234&quot;, nocut(_)).asInstanceOf[Parsed.Failure]
val trace = failure.trace().longAggregateMsg
assert(
  failure.index == 4,
  trace == &quot;&quot;&quot;Expected nocut:1:1 / alpha:1:5 / [a-z]:1:5, found &quot;1234&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L325-L336" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Cuts are added using the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> operator, which is similar to the <a href="#Sequence">Sequence</a> operator <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code>. Once the parse has crossed a cut, it can no longer backtrack past the point at which the cut occured. Hence, in this case you can see that it no longer backtracks to index 0, out of the enclosing <a href="#Either">Either</a> parser and offering that in the error trace. Instead, it shows a much more precise error: at index <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">4</code>, expecting one of the small set of alphanumeric characters.</p>
            <p>
                In general, if you know that a parser is &quot;committed&quot; to one branch after parsing to a certain point, adding a cut will greatly improve the error message by ensuring that the parser <i>itself</i> knows that. Good places to add cuts include places like after keywords in a programming language parser, where a keyword can be followed by only one thing and anything else is an error.</p>
        <h2 id="RepCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#RepCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Rep Cuts</h2>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def alpha[$: P] = P( CharIn(&quot;a-z&quot;) )
def stmt[$: P] = P( &quot;val &quot; ~ alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
def stmts[$: P] = P( stmt.rep(1) ~ End )

val Parsed.Success(Seq(&quot;abcd&quot;), _) = parse(&quot;val abcd;&quot;, stmts(_))
val Parsed.Success(Seq(&quot;abcd&quot;, &quot;efg&quot;), _) = parse(&quot;val abcd; val efg;&quot;, stmts(_))

val failure = parse(&quot;val abcd; val &quot;, stmts(_)).asInstanceOf[Parsed.Failure]
val trace = failure.trace().longAggregateMsg
assert(
  failure.index == 10,
  trace == &quot;&quot;&quot;Expected stmts:1:1 / (&quot; &quot; | stmt | end-of-input):1:11, found &quot;val &quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L339-L352" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                A similar problem occurs inside <a href="#Repeat">Repeat</a> or <a href="#Optional">Optional</a> parsers, where the parser will give up and backtrack out if it fails, even if it really should succeed. Again, adding cuts would result in a more precise error message:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def alpha[$: P] = P( CharIn(&quot;a-z&quot;) )
def stmt[$: P] = P( &quot;val &quot; ~/ alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
def stmts[$: P] = P( stmt.rep(1) ~ End )

val Parsed.Success(Seq(&quot;abcd&quot;), _) = parse(&quot;val abcd;&quot;, stmts(_))
val Parsed.Success(Seq(&quot;abcd&quot;, &quot;efg&quot;), _) = parse(&quot;val abcd; val efg;&quot;, stmts(_))

val failure = parse(&quot;val abcd; val &quot;, stmts(_)).asInstanceOf[Parsed.Failure]
val trace = failure.trace().longAggregateMsg
assert(
  failure.index == 14,
  trace == &quot;&quot;&quot;Expected stmts:1:1 / stmt:1:11 / alpha:1:15 / [a-z]:1:15, found &quot;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L355-L368" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Another case where you may want to pay attention is when you are using delimiters with your <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> calls:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def digits[$: P] = P( CharIn(&quot;0-9&quot;).rep(1) )
def tuple[$: P] = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = parse(&quot;(1,23)&quot;, tuple(_))

val failure = parse(&quot;(1,)&quot;, tuple(_)).asInstanceOf[Parsed.Failure]
val trace = failure.trace().longAggregateMsg
assert(
  failure.index == 2,
  trace == &quot;&quot;&quot;Expected tuple:1:1 / ([0-9] | &quot;,&quot; ~ digits | &quot;)&quot;):1:3, found &quot;,)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L371-L382" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                in many (but not all!) cases, if a delimiter is parsed, you want to commit to parsing one more iteration of the <a href="#Repeat">Repeat</a>. However, by default, it backtracks out of the <a href="#Repeat">Repeat</a> entirely and starts trying to parse the next item in sequence (in this case the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> giving the behavior shown above.
</p>
            <p>
                With a cut, the error is improved:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def digits[$: P] = P( CharIn(&quot;0-9&quot;).rep(1) )
def tuple[$: P] = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;./) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = parse(&quot;(1,23)&quot;, tuple(_))

val failure = parse(&quot;(1,)&quot;, tuple(_)).asInstanceOf[Parsed.Failure]
val index = failure.index
val trace = failure.trace().longAggregateMsg
assert(
  index == 3,
  trace == &quot;&quot;&quot;Expected tuple:1:1 / digits:1:4 / [0-9]:1:4, found &quot;)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L385-L397" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">./</code> operator can be used without a following parser as a shortcut for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/ Pass</code>. Compare the previous example with the following one:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def digits[$: P] = P( CharIn(&quot;0-9&quot;).rep(1) )
def tuple[$: P] = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;./) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = parse(&quot;(1,23)&quot;, tuple(_))

val failure = parse(&quot;(1,)&quot;, tuple(_)).asInstanceOf[Parsed.Failure]
val trace = failure.trace().longAggregateMsg
assert(
  failure.index == 3,
  trace == &quot;&quot;&quot;Expected tuple:1:1 / digits:1:4 / [0-9]:1:4, found &quot;)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L400-L411" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="IsolatingCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IsolatingCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Isolating Cuts</h2>
            <p>
                Because cuts prevent backtracking throughout the entire parser, they make it difficult to compose arbitrary parsers:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def digit[$: P] = P( CharIn(&quot;0-9&quot;) )
def time1[$: P] = P( (&quot;1&quot;.? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit ~ (&quot;am&quot; | &quot;pm&quot;) )
def time2[$: P] = P( ((&quot;1&quot; | &quot;2&quot;).? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit )
val Parsed.Success((), _) = parse(&quot;12:30pm&quot;, time1(_))
val Parsed.Success((), _) = parse(&quot;17:45&quot;, time2(_))
def time[$: P] = P( time1 | time2 ).log
val Parsed.Success((), _) = parse(&quot;12:30pm&quot;, time(_))
val failure = parse(&quot;17:45&quot;, time(_)).asInstanceOf[Parsed.Failure]
assert(failure.index == 5)  // Expects am or pm</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L414-L423" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                In the above case, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time2</code> are arbitrary parsers containing <a href="#Cuts">Cuts</a>. By default, that means that once you've crossed a cut, you can no longer backtrack. However, there are cases where you want to use an existing parser (for example <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code>) in a situation where you want to allow it to backtrack, but you don't want to rewrite it identically but without cuts. In this case it's trivial, but if <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code> was larger you would need to rewrite all of it as well as all of its transitive sub-parsers to make sure that not a single one had a cut inside!
</p>
            <p>
                To explicitly isolate a cut to one branch of a parser, place that branch within <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">NoCut</code>.  Cuts within that branch will prevent backtracking inside that branch, but if that branch fails alternate branches will be tried as normal.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def digit[$: P] = P( CharIn(&quot;0-9&quot;) )
def time1[$: P] = P( (&quot;1&quot;.? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit ~ (&quot;am&quot; | &quot;pm&quot;) )
def time2[$: P] = P( ((&quot;1&quot; | &quot;2&quot;).? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit )
val Parsed.Success((), _) = parse(&quot;12:30pm&quot;, time1(_))
val Parsed.Success((), _) = parse(&quot;17:45&quot;, time2(_))
def time[$: P] = P( NoCut(time1) | time2 )
val Parsed.Success((), _) = parse(&quot;12:30pm&quot;, time(_))
val Parsed.Success((), _) = parse(&quot;17:45&quot;, time(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L426-L434" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="HigherOrderParsers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HigherOrderParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Higher Order Parsers</h1>

        <p>
            It is possible to write functions that take parsers as arguments and return other parsers. These are useful because it allows for the programmatic modification of many different parsers. This can be used to generate a large amount of parsers that only vary in minor ways.
</p>
        <p>
            Parser arguments <b>must be passed by name</b>! Parsers are immediately evaluated, so if they aren't passed by name they will be evaluated when they are passed into a function, not within it, causing either a warning about <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a pure expression does nothing in statement position</code> at compile time or a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ClassCastException</code> at runtime.
</p>
        <p>
            A simple example of a higher order parser is one that adds index information to the beginning and end of the parse.
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def Indexed[$: P, T](p: =&gt; P[T]): P[(Int, T, Int)] = P( Index ~ p ~ Index )

def Add[$: P] = P( Num ~ &quot;+&quot; ~ Num )
def Num[$: P] = Indexed( CharsWhileIn(&quot;0-9&quot;).rep.! )

val Parsed.Success((0, &quot;1&quot;, 1, (2, &quot;2&quot;, 3)), _) = parse(&quot;1+2&quot;, Add(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L529-L535" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            While this is a simple example, this concept to be extended to your hearts content.</p>


    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="StreamingParsing" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Streaming Parsing<a class=" scalatex-site-Styles-headerLink" href="#StreamingParsing" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        In addition to the parsing strings, you can also parse &quot;streaming&quot;
        data from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator</code>s. To do so, simply pass in an
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator[String]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">java.io.InputStream</code> instead
        of a <code>String</code> to the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.parse</code> method.
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import NoWhitespace._
def p[$: P] = P( &quot;ab&quot; ~/ &quot;cd&quot;.rep().! ~ &quot;ef&quot; | &quot;z&quot; )

val Parsed.Success(res, i) = parse(Iterator(&quot;ab&quot;, &quot;cd&quot;, &quot;cd&quot;, &quot;cd&quot;, &quot;ef&quot;), p(_))

assert(res == &quot;cdcdcd&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src-2.12+/fastparse/IteratorTests.scala#L26-L32" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        Streaming parsing still needs to buffer input in-memory: in particular,
        parsers like <a href="#Optional">Optional</a>, <a href="#Repeat">Repeat</a> or
        <a href="#Either">Either</a> means a parser may backtrack, and thus FastParse
        needs to buffer any input from where such a parsers starts parsing.
        Other parsers like <a href="#Capture">Capture</a> do not backtrack, but need
        to buffer data in order to return the data that gets captured. Using
        <a href="#Cuts">Cuts</a> to prevent backtracking, apart from making
        <a href="#DebuggingParsers">Debugging Parsers</a> easier, also allows FastParse to flush
        parts of the buffer that it no longer needs to backtrack into.
</p>
    <p>
        <i>
            In general every cut in your parser possibly reduces the memory
            used to buffer input for iterator parsing

</i></p>
    <h1 id="StreamingParsingBufferSize" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StreamingParsingBufferSize" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Streaming Parsing Buffer Size</h1>
        <p>
            This first benchmark measures the maximum size of buffered input
            when using streaming parsing, for some sample parsers we have in
            the test suite, for input-chunks of size 1 and 1024:
</p>
        <table style="width: 100%;" class="pure-table">
            <thead>
                <th>Parser</th>
                <th>Maximum buffer <br /> for 1-sized chunk</th>
                <th>Maximum buffer <br /> for 1024-sized chunk</th>
                <th>Size of input</th>
                <th>Used memory</th></thead>
            <tbody>
                <tr>
                    <td>ScalaParse</td><td>1555</td><td>2523</td><td>147894</td><td>1.4%</td></tr>
                <tr>
                    <td>PythonParse</td><td>2006</td><td>2867</td><td>68558</td><td>3.6%</td>
</tr></tbody></table>
        <p>
            As you can see, for these &quot;typical&quot; parsers, some input needs to
            be buffered to allow backtracking, but it turns out to be only a
            few percent of the total file size.</p>
        <p>
            These parsers make heavy use of backtracking operators like
            <a href="#Either">Either</a> or <a href="#Repeat">Repeat</a>, but also make
            heavy use of <a href="#Cuts">Cuts</a>. This lets FastParse drop buffered
            input when it knows it can no longer backtrack.</p>
        <p>
            Another thing to note is the chunk size: a smaller chunk size
            reduces the granularity of the chunks that get buffered,
            reducing the buffer size. However, this comes at a performance
            cost, as you can see below...</p>
        <p>
            When parsing <code>Iterator[String]</code>s, the chunks-size is the size of
            each <code>String</code>. When parsing <code>java.io.InputStream</code>, the chunk
            size defaults to 4096 bytes, and can be configured by instatiating your own
            <code>fastparse.ParserInputSource.FromReadable</code>.
</p>
    <h1 id="StreamingParsingPerformance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StreamingParsingPerformance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Streaming Parsing Performance</h1>
        <p>
            This next benchmark measures the effect of streaming parsing on
            runtime performance, using two different chunk-sizes, compared
            to the performance of non-streaming parsing:
</p>
        <table style="width: 100%;" class="pure-table">
            <thead>
                <th>Parser</th>
                <th>Score on the plain parsing</th>
                <th>Score on the iterator parsing <br /> for 1-sized chunk</th>
                <th>Score on the iterator parsing <br /> for 1024-sized chunk</th></thead>
            <tbody>
                <tr>
                    <td>ScalaParse</td><td>43</td><td>33</td><td>43</td></tr>
                <tr>
                    <td>PythonParse</td><td>1150</td><td>600</td><td>890</td>
</tr></tbody></table>
        <p>
            Here, we can see that streaming parsing has a non-trivial effect
            on performance: ScalaParse seems unaffected by a chunks of size
            1024, and takes a 25% performance hit for chunks of size 1, but
            PythonParse takes a significant hit (25%, 47%). While smaller chunk sizes
            results in smaller buffers, it also comes with a performance
            cost. Exactly how big you want your input chunks to be is up to
            you to decide: FastParse will accept an iterator of chunks
            as large or as small as you want.
</p>
        <p>
            In general, Streaming Parsing it always going to be a
            performance hit over parsing a single <code>String</code> you
            pre-loaded in memory. The point of streaming parsing is to
            handle cases where you can't/don't-want-to load everything in
            memory. In that case, if the choice is between slightly-slower
            parsing or an <code>OutOfMemory</code> error, streaming parsing is
            a good option to have.
</p>
    <h1 id="StreamingParsingLimitations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StreamingParsingLimitations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Streaming Parsing Limitations</h1>
        <p>
            Apart from the performance/memory tradeoff mentioned above,
            streaming parsing has some limitations that it is worth being aware of:</p>
        <ul>
            <li>
                Performance of iterator parsing is always going to be
                slower than performance of raw <code>String</code>
                parsing: this is unavoidable given the overhead of maintaining
                and trimming the input buffer</li>
            <li>
                Memory use when parsing iterators is always going to depend
                on aggressive use of <a href="#Cuts">Cuts</a> within the parser: most
                real-world parsers rely heavily on <a href="#Optional">Optional</a>,
                <a href="#Repeat">Repeat</a> and <a href="#Either">Either</a>, all of which will
                cause input to be buffered in memory unless you use
                <a href="#Cuts">Cuts</a> to avoid backtracking</li>
            <li>
                You can't use <a href="#Tracing">Tracing</a> after parsing an iterator:
                tracing performs a second parse on the same input to generate
                its error information, and the iterator input gets exhausted after
                the first parsing pass and are not available for a second time.</li>
            <li>
                Streaming parsing does not support parsing
                <code>scala.Stream[String]</code>, as <code>scala.Stream</code> buffers
                everything in memory, making it pretty useless from a
                perspective of &quot;streaming parsing&quot; where you explicitly
                <i>don't</i> want to do that.</li>
            <li>
                Streaming parsing does not (and will likely never) support
                <a href="http://stackoverflow.com/questions/15895124/what-is-push-approach-and-pull-approach-to-parsing">&quot;async&quot; or &quot;push&quot; parsing</a>.
                This is because FastParse's entire execution model is based
                on a straightforward recursive-descent over the input stream.
                It's unlikely we'll ever be able to graft async-parsing
                on top of this execution model.</li></ul>

    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ExampleParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Example Parsers<a class=" scalatex-site-Styles-headerLink" href="#ExampleParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        Above, we've already covered all the individual bits and pieces that make writing a parser possible. But how does that fit together? Let's take a look at some examples.
</p>
    <h1 id="Math" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Math" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Math</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse._, NoWhitespace._
def number[$: P]: P[Int] = P( CharIn(&quot;0-9&quot;).rep(1).!.map(_.toInt) )
def parens[$: P]: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
def factor[$: P]: P[Int] = P( number | parens )

def divMul[$: P]: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
def addSub[$: P]: P[Int] = P( divMul ~ (CharIn(&quot;+\\-&quot;).! ~/ divMul).rep ).map(eval)
def expr[$: P]: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L20-L29" target="_blank"><i class="fa fa-link "></i></a></pre>


        <p>
            This is a small arithmetic expression parser, the same one shown at
            the top of this page. It parses only whole integers, parentheses,
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">+-*/</code>, and no whitespace.</p>
        <p>
            Things to note:
</p>
        <ul>
            <li>
                The various sub-parsers are all of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P[Int]</code>,
                indicating that they result in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Int</code> if successful.
                Many of the type annotations could be removed due to
                type-inference, but they're shown here for clarity</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">divMul</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">addSub</code> are separated out, in
                order to properly account for precedence</li>
            <li>
                We evaluate the expression as the parse progresses, meaning we
                never actually build an tree structure from the input string</li>
            <li>
                In order to convert the parsed strings to integers, we
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">map</code> on the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">eval</code> function, which
                itself is defined earlier:
</li></ul>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def eval(tree: (Int, Seq[(String, Int)])) = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L13-L20" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            This is a small example, but it works. We check it to verify that every parse results in the expected integer:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success(2, _) = parse(&quot;1+1&quot;, expr(_))
val Parsed.Success(15, _) = parse(&quot;(1+1*2)+3*4&quot;, expr(_))
val Parsed.Success(21, _) = parse(&quot;((1+1*2)+(3*4*5))/3&quot;, expr(_))
val Parsed.Failure(expected, failIndex, extra) = parse(&quot;1+1*&quot;, expr(_))
val longAggMsg = extra.trace().longAggregateMsg
assert(
  failIndex == 4,
  longAggMsg ==
  &quot;&quot;&quot;Expected expr:1:1 / addSub:1:1 / divMul:1:3 / factor:1:5 / (number | parens):1:5, found &quot;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L31-L41" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Try it out yourself! Remember that it does not handle whitespace:
</p>
        <div id="mathdiv"></div>
        <script>DemoMain.math(document.getElementById("mathdiv"))</script>

    <h1 id="WhitespaceHandling" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhitespaceHandling" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Whitespace Handling</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import SingleLineWhitespace._
def eval(tree: (Int, Seq[(String, Int)])): Int = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}
def number[$: P]: P[Int] = P( CharIn(&quot;0-9&quot;).rep(1).!.map(_.toInt) )
def parens[$: P]: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
def factor[$: P]: P[Int] = P( number | parens )

def divMul[$: P]: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
def addSub[$: P]: P[Int] = P( divMul ~ (CharIn(&quot;+\\-&quot;).! ~/ divMul).rep ).map(eval)
def expr[$: P]: P[Int]   = P( &quot; &quot;.rep ~ addSub ~ &quot; &quot;.rep ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/WhitespaceMathTests.scala#L9-L25" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            To handle whitespace and other non-significant characters with
            FastParse, we can replace the normal <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import NoWhitespace._</code>
            with a whitespace consumer that picks up the whitespace we want,
            e.g. <code>SingleLineWhitespace</code> for skipping spaces, tabs,
            <code>MultiLineWhitespace</code> for also skipping newlines, and
            <code>ScriptWhitespace</code>/<code>JavaWhitespace</code>/<code>ScalaWhitespace</code>
            for also skipping various sorts of comments (<code>#</code>-delimited,
            <code>//</code> and <code>/* */</code> delimited, and allowing nested <code>/* */</code>s
            respectively)
</p>
        <p>
            The whitespace consumer affects the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code>
            operators to consume all non-trailing whitespace and ignoring it
            (use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~~</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.repX</code> instead if you need to access
            non-whitespace-consuming operators in certain cases).
</p>
        <p>
            Here it is in action:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Parsed.Success(value, _) = parse(str, expr(_))
  assert(value == num)
}

test - check(&quot;1+1&quot;, 2)
test - check(&quot;1+   1*   2&quot;, 3)
test - check(&quot;(1+   1  *  2)+(   3*4*5)&quot;, 63)
test - check(&quot;15/3&quot;, 5)
test - check(&quot;63  /3&quot;, 21)
test - check(&quot;(1+    1*2)+(3      *4*5)/20&quot;, 6)
test - check(&quot;((1+      1*2)+(3*4*5))/3&quot;, 21)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/WhitespaceMathTests.scala#L27-L39" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            You can also define your own custom whitespace consumer, if none of
            bundled ones fit your needs:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">implicit object whitespace extends Whitespace{
  def apply(implicit ctx: P[_]): P[Unit] = {
    CharsWhileIn(&quot; \t&quot;, 0)
  }
}
def eval(tree: (Int, Seq[(String, Int)])): Int = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}
def number[$: P]: P[Int] = P( CharIn(&quot;0-9&quot;).rep(1).!.map(_.toInt) )
def parens[$: P]: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
def factor[$: P]: P[Int] = P( number | parens )

def divMul[$: P]: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
def addSub[$: P]: P[Int] = P( divMul ~ (CharIn(&quot;+\\-&quot;).! ~/ divMul).rep ).map(eval)
def expr[$: P]: P[Int]   = P( &quot; &quot;.rep ~ addSub ~ &quot; &quot;.rep ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src-2.12+/fastparse/CustomWhitespaceMathTests.scala#L9-L29" target="_blank"><i class="fa fa-link "></i></a></pre>



        <p>
            Or try it yourself:
</p>
        <div id="wsmathdiv"></div>
        <script>DemoMain.whitespaceMath(document.getElementById("wsmathdiv"))</script>

    <h1 id="IndentationGrammars" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IndentationGrammars" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Indentation Grammars</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def eval(tree: (String, Seq[Int])) = tree match{
  case (&quot;+&quot;, nums) =&gt; nums.reduceLeft(_+_)
  case (&quot;-&quot;, nums) =&gt; nums.reduceLeft(_-_)
  case (&quot;*&quot;, nums) =&gt; nums.reduceLeft(_*_)
  case (&quot;/&quot;, nums) =&gt; nums.reduceLeft(_/_)
}

/**
  * Parser for an indentation-based math syntax. Parens are no longer
  * necessary, and the whole parser is parametrized with the current
  * depth of indentation
  */
class Parser(indent: Int){
  def number[$: P]: P[Int] = P( CharIn(&quot;0-9&quot;).rep(1).!.map(_.toInt) )

  def deeper[$: P]: P[Int] = P( &quot; &quot;.rep(indent + 1).!.map(_.length) )
  def blockBody[$: P]: P[Seq[Int]] = &quot;\n&quot; ~ deeper.flatMapX(i =&gt;
    new Parser(indent = i).factor.rep(1, sep = (&quot;\n&quot; + &quot; &quot; * i)./)
  )
  def block[$: P]: P[Int] = P( CharIn(&quot;+\\-*/&quot;).! ~/ blockBody).map(eval)

  def factor[$: P]: P[Int] = P( number | block )

  def expr[$: P]: P[Int]   = P( block ~ End )
}
def expr[$: P] = new Parser(indent = 0).expr</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/IndentationTests.scala#L11-L38" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
            Here is a grammar that is used to parse a simple indentation-based math grammar. To understand the grammar it is trying to parse, it is worth looking at the test data:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Parsed.Success(value, _) = parse(str, expr(_))
  assert(value == num)
}

check(
  &quot;&quot;&quot;+
    |  1
    |  1
  &quot;&quot;&quot;.stripMargin.trim,
  2
)

check(
  &quot;&quot;&quot;+
    |  1
    |  *
    |    1
    |    2
  &quot;&quot;&quot;.stripMargin.trim,
  3
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/IndentationTests.scala#L40-L63" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            As you can see, it is basically a prefix math evaluator, where you use indentation to pass the numbers or expressions to each operator to operate on.
</p>
        <p>
            As for the parser, the novel things are:
</p>
        <ul>
            <li>
                All the rules live in a class parametrized on the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">indent</code> that is currently in place</li>
            <li>
                At each level, the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">factor</code>s (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">number</code>s or further <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">block</code>s) inside a block are separated by a newline and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">indent</code> spaces</li>
            <li>
                The initial top-level <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> rule starts off with indentation <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">0</code></li>
            <li>
                After parsing an operator, we use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">deeper</code> to figure out how deep the first line of the indented block is.</li>
            <li>
                We then use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> to increment the indentation to the new value and parse the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">factor</code>s at that indentation.
</li></ul>
        <p>
            Note how there is no pre-processing, and no lexining phase where the lexer has to guess where in the token stream to inject synthetic indent and dedent tokens, Everything happens in a single pass.</p>
        <p>
            Try it out!</p>
        <div id="indentdiv"></div>
        <script>DemoMain.indentation(document.getElementById("indentdiv"))</script>

    <h1 id="Json" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Json" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Json</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">sealed trait Val extends Any {
  def value: Any
  def apply(i: Int): Val = this.asInstanceOf[Arr].value(i)
  def apply(s: java.lang.String): Val =
    this.asInstanceOf[Obj].value.find(_._1 == s).get._2
}
case class Str(value: java.lang.String) extends AnyVal with Val
case class Obj(value: (java.lang.String, Val)*) extends AnyVal with Val
case class Arr(value: Val*) extends AnyVal with Val
case class Num(value: Double) extends AnyVal with Val
case object False extends Val{
  def value = false
}
case object True extends Val{
  def value = true
}
case object Null extends Val{
  def value = null
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/JsonTests.scala#L8-L27" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse._, NoWhitespace._
def stringChars(c: Char) = c != '\&quot;' &amp;&amp; c != '\\'

def space[$: P]         = P( CharsWhileIn(&quot; \r\n&quot;, 0) )
def digits[$: P]        = P( CharsWhileIn(&quot;0-9&quot;) )
def exponent[$: P]      = P( CharIn(&quot;eE&quot;) ~ CharIn(&quot;+\\-&quot;).? ~ digits )
def fractional[$: P]    = P( &quot;.&quot; ~ digits )
def integral[$: P]      = P( &quot;0&quot; | CharIn(&quot;1-9&quot;)  ~ digits.? )

def number[$: P] = P(  CharIn(&quot;+\\-&quot;).? ~ integral ~ fractional.? ~ exponent.? ).!.map(
  x =&gt; Js.Num(x.toDouble)
)

def `null`[$: P]        = P( &quot;null&quot; ).map(_ =&gt; Js.Null)
def `false`[$: P]       = P( &quot;false&quot; ).map(_ =&gt; Js.False)
def `true`[$: P]        = P( &quot;true&quot; ).map(_ =&gt; Js.True)

def hexDigit[$: P]      = P( CharIn(&quot;0-9a-fA-F&quot;) )
def unicodeEscape[$: P] = P( &quot;u&quot; ~ hexDigit ~ hexDigit ~ hexDigit ~ hexDigit )
def escape[$: P]        = P( &quot;\\&quot; ~ (CharIn(&quot;\&quot;/\\\\bfnrt&quot;) | unicodeEscape) )

def strChars[$: P] = P( CharsWhile(stringChars) )
def string[$: P] =
  P( space ~ &quot;\&quot;&quot; ~/ (strChars | escape).rep.! ~ &quot;\&quot;&quot;).map(Js.Str.apply)

def array[$: P] =
  P( &quot;[&quot; ~/ jsonExpr.rep(sep=&quot;,&quot;./) ~ space ~ &quot;]&quot;).map(Js.Arr(_:_*))

def pair[$: P] = P( string.map(_.value) ~/ &quot;:&quot; ~/ jsonExpr )

def obj[$: P] =
  P( &quot;{&quot; ~/ pair.rep(sep=&quot;,&quot;./) ~ space ~ &quot;}&quot;).map(Js.Obj(_:_*))

def jsonExpr[$: P]: P[Js.Val] = P(
  space ~ (obj | array | string | `true` | `false` | `null` | number) ~ space
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/JsonTests.scala#L34-L70" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            This is a somewhat larger example than the math parser shown above. In it, we parse a JSON expression from a string, including all the proper handling for whitespace and error-handling built in.
</p>
        <p>
            Things to note:
</p>
        <ul>
            <li>
                We use cuts (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code>) liberally in order to improve the quality of errors. Anywhere there's an <a href="#Either">Either</a> or <a href="#Repeat">Repeat</a>, the children have cuts once the parse has progressed far enough backtracking isn't an option.</li>
            <li>
                We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharIn</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> quite a lot, in order to speed up the common case of consuming lots of boring characters.</li>
            <li>
                In <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code>, we break out of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> closing quote (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'&quot;'</code>) or whenever we see the start of an escape sequence (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'\'</code>). Although <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> can't process these multi-char sequences, we let the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">escape</code> parser deal with these before trying to fall back to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code> after. This lets us speed up the &quot;common&quot; case of consuming large numbers of non-escape characters, while still properly handling escapes.</li>
            <li>
                We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> to convert the various things we parse into instances of our own <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.Val</code> JSON AST:

</li></ul>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def apply(i: Int): Val = this.asInstanceOf[Arr].value(i)
def apply(s: java.lang.String): Val =
  this.asInstanceOf[Obj].value.find(_._1 == s).get._2</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/JsonTests.scala#L10-L13" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            We can verify that this parser builds the JSON tree that we expect:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success(value, _) =
  parse(&quot;&quot;&quot;{&quot;omg&quot;: &quot;123&quot;, &quot;wtf&quot;: 12.4123}&quot;&quot;&quot;, jsonExpr(_))

assert(value == Js.Obj(&quot;omg&quot; -&gt; Js.Str(&quot;123&quot;), &quot;wtf&quot; -&gt; Js.Num(12.4123)))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/JsonTests.scala#L95-L99" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            And that it provides good error messages in the case of mal-formed JSON, even for moderately-sized fragemnts
</p>
        
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">{
    &quot;firstName&quot;: &quot;John&quot;,
    &quot;lastName&quot;: &quot;Smith&quot;,
    &quot;age&quot;: 25,
    &quot;address&quot;: {
        &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,
        &quot;city&quot;: &quot;New York&quot;,
        &quot;state&quot;: &quot;NY&quot;,
        &quot;postalCode&quot;: 10021
    },
    &quot;phoneNumbers&quot;:
        {
            &quot;type&quot;: &quot;home&quot;,
            &quot;number&quot;: &quot;212 555-1234&quot;
        },
        {
            &quot;type&quot;: &quot;fax&quot;,
            &quot;number&quot;: &quot;646 555-4567&quot;
        }
    ]
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/JsonTests.scala#L306-L327" target="_blank"><i class="fa fa-link "></i></a></pre>

        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">jsonExpr:1:1 / obj:2:9 / pair:16:19 / string:16:19 / &quot;\&quot;&quot;:17:17 ...&quot;{\n        &quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/JsonTests.scala#L329-L330" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Here, we're missing a square bracket after the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;phoneNumbers&quot;</code> key, and so the parser expects to find a single JSON expression. It finds a JSON object, and then fails reporting that it expected to find the next key (a string), but instead found <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;{\n&quot;</code> at that index.
</p>
        <p>
            Try it out!
</p>
        <div id="jsondiv"></div>
        <script>DemoMain.json(document.getElementById("jsondiv"))</script>

    <h1 id="ScalaParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ScalaParse</h1>

        <div id="scaladiv"></div>
        <script>DemoMain.scalaparser(document.getElementById("scaladiv"))</script>

        <p>
            ScalaParse is a parser for the entire Scala programming language, written using FastParse. This is notable for a few reasons:
</p>
        <ul>
            <li>
                ScalaParse is about 700 lines of code, making it about 1/10th the size of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
            <li>
                ScalaParse runs about <a href="#Performance">1/8th the speed</a> of of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
            <li>
                ScalaParse has excellent error reporting due to proper use of <a href="#Cuts">Cuts</a>, without any code explicitly dedicated to error reporting</li></ul>
        <p>
            ScalaParse does not currently generate an AST. As you can see, the parse result above is listed as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">undefined</code>. However, that does not make it useless! Even without generating an AST, ScalaParse can be used to:
</p>
        <ul>
            <li>
                Check for errors! ScalaParse provides excellent error reporting on parses, equal or better than that provided by the tools.nsc.Global parser, entirely for free.</li>
            <li>
                Prototype extensions to the Scala grammar! Unlike the default tools.nsc.Global parser, ScalaParse makes it trivial to add new rules at various sections of the grammar.</li>
            <li>
                Manipulate Scala code sections! It's trivial to wrap various rules in ScalaParse in an <a href="#Capture">Capture</a> and use it to pull out the relevant bits of a Scala file for you to use.

</li></ul>
        <h2 id="UsingScalaParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using ScalaParse</h2>
            <p></p>
            To begin using ScalaParse, add

            <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;scalaparse&quot; % &quot;2.0.5&quot;
</code></pre>
            <p>
                To your SBT configuration. To use with Scala.js, you'll need
</p>
            <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;scalaparse&quot; % &quot;2.0.5&quot;
</code></pre>
    <h1 id="PythonParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PythonParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>PythonParse</h1>
        <div id="pythondiv"></div>
        <script>DemoMain.python(document.getElementById("pythondiv"))</script>
        <p>
            There is now an <a href="https://github.com/lihaoyi/fastparse/tree/master/pythonparse/shared/src/main/scala/pythonparse">example Python parser</a> available under a subproject in the repo. This is a good example of a real-world parser: parsing knotty syntax (including indentation-delimited blocks!), building an AST, and with heavy unit tests.
</p>
        <p>
            PythonParse is currently compatible enough to parse all the python sources in Zulip, Ansible, Changes, Django, and Flask. It isn't published yet on maven central, but feel free to look at it if you want an idea of how to write a complex, real parser.
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;pythonparse&quot; % &quot;2.0.5&quot;
</code></pre>
    <h1 id="CssParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CssParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CssParse</h1>
        <p>
            CssParse is a parser that parses CSS files into an abstract syntax tree (AST).
            The implementation is too large to show in-line, but can be found here:</p>
        <ul>
            <li>
                <a href="https://github.com/lihaoyi/fastparse/tree/master/cssparse/shared/src/main/scala/cssparse">CssParse</a>
</li></ul>
        <p>
            This AST can then be used for a variety of reasons: you could
            analyze the CSS to try and find bugs, transform the CSS in some
            custom way (e.g. prefixing class-names with the name of the file)
            or just re-formatting the CSS when printing it back out.</p>
        <p>
            CssParse compiles to Javascript via Scala.js, and we have a demo
            here that demonstrates the use of CssParse as a CSS pretty-printer.
            Enter some CSS in the box below, no matter how it's formatted or
            minified, and CssParse will add the necessary spaces and tabs to make
            the file readable and good-looking.
</p>
        <div id="cssdiv"></div>
        <script>DemoMain.css(document.getElementById("cssdiv"))</script>

        <p>
            As mentioned above, CssParse builds and AST that stores
            information about tags and rules in the given CSS, this AST isn't
            complete, because of complexity of initial CSS format,
            but it provides all the essential information about basic elements
            of file (blocks, selectors, rules). The correctness of CssParse is
            tested by parsing and then printing several huge files including CSS
            from Bootstrap and Primer.
</p>
        <p>
            This is available on Maven Central as
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;cssparse&quot; % &quot;2.0.5&quot;</code></pre>


    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="APIHighlights" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">API Highlights<a class=" scalatex-site-Styles-headerLink" href="#APIHighlights" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="ParsingResults" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ParsingResults" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Parsing Results</h1>
        <p>
            The result of a parser comes in two flavors of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>;
            the first is a success (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code>) and the second
            is a failure (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code>). <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code>
            provides the parsed value - the value you are probably most
            interested in - and the index in the input string till where the
            parse was performed. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code> allows you to
            retrieve the last parser that failed and the index where it failed.
            Additionally, failure provides an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure.extra</code>
            field that provides precise details about the failure, in particular,
            and most importantly a complete stack trace of the involved parsers,
            which is accessible via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">extra.traced</code>.
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">sealed trait AndOr
case object And extends AndOr
case object Or extends AndOr
def and[$: P] = P(IgnoreCase(&quot;And&quot;)).map(_ =&gt; And)
def or[$: P] = P(IgnoreCase(&quot;Or&quot;)).map(_ =&gt; Or)
def andOr[$: P] = P(and | or)

def check(input: String, expectedOutput: String) = {
  val folded = parse(input, andOr(_)).fold(
    (_, _, _) =&gt; s&quot;Cannot parse $input as an AndOr&quot;,
    (v, _) =&gt; s&quot;Parsed: $v&quot;
  )
  assert(folded == expectedOutput)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L538-L551" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            It is also possible to pattern match over <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>, however, you may experience spurious warnings related to <a href="https://issues.scala-lang.org/browse/SI-4440">SI-4440</a>.
            In order to prevent these warnings <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.core.Result</code> in versions 0.2.x and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.core.Parsed</code> in higher versions than 0.2.x.
</p>
        <p>
            An overview of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">package fastparse

import fastparse.internal.{Msgs, Util}

/**
  * The outcome of a [[ParsingRun]] run, either a success (with value and index) or
  * failure (with associated debugging metadata to help figure out what went
  * wrong).
  *
  * Doesn't contain any information not already present in [[ParsingRun]], but
  * packages it up nicely in an immutable case class that's easy for external
  * code to make use of.
  */
sealed abstract class Parsed[+T](val isSuccess: Boolean){
  def fold[V](onFailure: (String, Int, Parsed.Extra) =&gt; V, onSuccess: (T, Int) =&gt; V): V
  def get: Parsed.Success[T]
}

object Parsed{
  def fromParsingRun[T](p: ParsingRun[T]): Parsed[T] = {
    if (p.isSuccess) Parsed.Success(p.successValue.asInstanceOf[T], p.index)
    else Parsed.Failure(
      Option(p.lastFailureMsg).fold(&quot;&quot;)(_.render),
      p.index,
      new Parsed.Extra(p.input, p.startIndex, p.index, p.originalParser, p.failureStack)
    )
  }

  /**
    * The outcome of a successful parse
    *
    * @param value The value returned by the parse
    * @param index The index at which the parse completed at
    */
  final case class Success[+T](value: T, index: Int) extends Parsed[T](true){
    def get = this
    def fold[V](onFailure: (String, Int, Extra) =&gt; V, onSuccess: (T, Int) =&gt; V) = onSuccess(value, index)
    override def toString() = s&quot;Parsed.Success($value, $index)&quot;
  }

  /**
    * The outcome of a failed parse
    *
    * @param label A hint as to why the parse failed. Defaults to &quot;&quot;,
    *                     unless you set `verboseFailures = true` or call
    *                     `.trace()` on an existing failure
    * @param index The index at which the parse failed
    * @param extra Metadata about the parse; useful for re-running the parse
    *              to trace out a more detailed error report
    */
  final class Failure(val label: String,
                      val index: Int,
                      val extra: Extra) extends Parsed[Nothing](false){
    def get = throw new Exception(&quot;Parse Error, &quot; + msg)
    def fold[V](onFailure: (String, Int, Extra) =&gt; V, onSuccess: (Nothing, Int) =&gt; V) = onFailure(label, index, extra)
    override def toString() = s&quot;Parsed.Failure($msg)&quot;

    /**
      * Displays the failure message excluding the parse stack
      */
    def msg = {
      label match{
        case &quot;&quot; =&gt;
          &quot;Position &quot; + extra.input.prettyIndex(index) +
          &quot;, found &quot; + Failure.formatTrailing(extra.input, index)
        case s =&gt; Failure.formatMsg(extra.input, List(s -&gt; index), index)
      }
    }

    /**
      * Displays the failure message including the parse stack, if possible
      */
    def longMsg = {
      if (extra.stack.nonEmpty) {
        Failure.formatMsg(extra.input, extra.stack ++ List(label -&gt; index), index)
      } else throw new Exception(
        &quot;`.longMsg` requires the parser to be run with `verboseFailures = true`, &quot; +
        &quot;or to be called via `.trace().longMsg` or `.trace().longAggregateMsg`&quot;
      )
    }

    /**
      * Re-runs the failed parse with `verboseFailures` turned on and failure
      * aggregation enabled. This allows Fastparse to provide much more
      * detailed error messages, at a cost of taking ~2x as long than the
      * original parse.
      *
      * By default, logging is disabled during the tracing run; this is because
      * you typically already saw the logging output during the primary parse,
      * and the tracing run's log output should be identical. You can pass in
      * `enableLogging = true` to log the tracing run as well.
      */
    def trace(enableLogging: Boolean = false) = extra.trace(enableLogging)
  }

  object Failure{
    def apply(label: String, index: Int, extra: Extra) = new Failure(label, index, extra)
    def unapply(f: Failure): Some[(String, Int, Extra)] =
      Some((f.label, f.index, f.extra))
    def formatMsg(input: ParserInput, stack: List[(String, Int)], index: Int) = {
      &quot;Expected &quot; + Failure.formatStack(input, stack) +
      &quot;, found &quot; + Failure.formatTrailing(input, index)
    }
    def formatStack(input: ParserInput, stack: List[(String, Int)]) = {
      stack.map{case (s, i) =&gt; s&quot;$s:${input.prettyIndex(i)}&quot;}.mkString(&quot; / &quot;)
    }
    def formatTrailing(input: ParserInput, index: Int) = {
      Util.literalize(input.slice(index, index + 10))
    }
  }

  class Extra(val input: ParserInput,
              val startIndex: Int,
              val index: Int,
              val originalParser: ParsingRun[_] =&gt; ParsingRun[_],
              val stack: List[(String, Int)]) {
    @deprecated(&quot;Use .trace instead&quot;)
    def traced = trace()

    /**
      * Re-runs the failed parse with aggregation turned on. This is the
      * slowest of Fastparse's error reporting mode, taking ~2x as long
      * as the original parse, but provides the greatest detail in the error
      * message
      *
      * By default, logging is disabled during the tracing run; this is because
      * you typically already saw the logging output during the primary parse,
      * and the tracing run's log output should be identical. You can pass in
      * `enableLogging = true` to log the tracing run as well.
      */
    def trace(enableLogging: Boolean = false) = {
      input.checkTraceable()
      TracedFailure.fromParsingRun(
        parseInputRaw[Any](
          input,
          originalParser,
          startIndex = startIndex,
          traceIndex = index,
          enableLogging = enableLogging,
          verboseFailures = true
        )
      )
    }
  }

  object TracedFailure{

    def fromParsingRun[T](p: ParsingRun[T]) = {
      assert(!p.isSuccess)
      TracedFailure(
        p.terminalMsgs,
        p.aggregateMsgs,
        Parsed.fromParsingRun(p).asInstanceOf[Failure]
      )
    }
  }

  /**
    * A decorated [[Failure]] with extra metadata; provides a much more
    * detailed, through verbose, of the possible inputs that may have been
    * expected at the index at which the parse failed.
    *
    * @param terminals A list of all the lowest level parsers which could have
    *                  succeeded at the failure index. These are things like
    *                  literal string parsers, [[CharIn]], [[CharPred]], etc.
    * @param groups A list of all the highest level parsers which could have
    *               succeeded at the given failure index. These give you a
    *               good
    * @param failure The raw failure object
    */
  case class TracedFailure(terminals: Msgs,
                           groups: Msgs,
                           failure: Failure){
    def label = failure.label
    def index = failure.index
    def input = failure.extra.input
    def stack = failure.extra.stack
    def terminalAggregateString = terminals.render

    def groupAggregateString = groups.render

    @deprecated(&quot;Use .msg instead&quot;)
    def trace = aggregateMsg
    /**
      * Displays the short failure message excluding the parse stack. This shows
      * the last parser which failed causing the parse to fail. Note that this
      * does not include other parsers which may have failed earlier; see [[terminalsMsg]]
      * and [[reportParseMsg]] for more detailed errors
      */
    def msg = failure.msg
    /**
      * Displays the terminals failure message, excluding the parse stack. This
      * includes a list of all lowest-level parsers which could have succeeded
      * at the failure index: literal strings, [[CharIn]], [[CharPred]]s, etc.
      * This gives you a detailed listing of how the parse could be corrected,
      * though it can be verbose.
      */
    def terminalsMsg = Failure.formatMsg(input, List(terminalAggregateString -&gt; index), index)

    /**
      * Displays the aggregate failure message, excluding the parse stack. This
      * includes a list of all highest-level parsers which could have succeeded
      * at the failure index. This gives you a good high-level overview of what
      * the parser expected, at the cost
      */
    def aggregateMsg = Failure.formatMsg(input, List(groupAggregateString -&gt; index), index)

    /**
      * A version of [[msg]] that includes the parse stack
      */
    def longMsg = failure.longMsg

    /**
      * A version of [[terminalsMsg]] that includes the parse stack.
      */
    def longTerminalsMsg = Failure.formatMsg(input, stack ++ Seq(terminalAggregateString -&gt; index), index)

    /**
      * A version of [[aggregateMsg]] that includes the parse stack
      */
    def longAggregateMsg = Failure.formatMsg(input, stack ++ Seq(groupAggregateString -&gt; index), index)
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/src/fastparse/Parsed.scala#L0-L223" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Note how <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code> only contains the parser which failed
            and a single index where the parse failed. Further debugging
            information is available via the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure.Extra</code> class.
            Especially the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TracedFailure</code> that is lazily-computed via
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.traced</code>, provides valuable information: It performs
            a whole new parse on the input data with additional instrumentation,
            and provides additional insight into why the parse failed.
</p>
        <p>
            Computing the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.traced</code> data is not done by default
            for performance reasons: the additional run takes about 3x longer
            than the initial run due to the instrumentation, for a total of 4x
            slowdown. If you want the information for debugging, though, it
            will be there.</p>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Performance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Performance<a class=" scalatex-site-Styles-headerLink" href="#Performance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        FastParse will never be able to compete with hand-written recursive
        descent parsers for speed, but for most use cases it is plenty fast
        enough. Here's a comparison of FastParse with alternatives, using
        Parboiled2's JSON parsing benchmark, which parses a ~21,500 line JSON file:
</p>
    <table style="width: 100%;" class="pure-table">
        <thead>
            <th>Benchmark</th><th>Score</th></thead>
        <tbody>
            <tr>
                <td>fastparse</td><td>159.5</td></tr>
            <tr>
                <td>circe</td><td>332.4</td></tr>
            <tr>
                <td>argonaut</td><td>149.1</td></tr>
            <tr>
                <td>uJson</td><td>266.6</td></tr>
            <tr>
                <td>json4s</td><td>100.9</td></tr>
            <tr>
                <td>play-json</td><td>226.6</td></tr>
            <tr>
                <td>scala-parser-combinators</td><td>0.9</td>

</tr></tbody></table>
    <p>
        These numbers are the number of iterations/second of parsing a sample
        <code>test.json</code> file, averaged over 200 runs. As you can see, the
        FastParse based parser comes within a factor of 4 of the fastest hand
        written parser (Jackson), is just as fast as the Parboiled2 based
        parser (slightly faster/slower depending if full tracing is enabled),
        and is almost 100x faster than the scala-parser-combinators library.
</p>
    <p>
        In exchange for the perf hit compared to hand-rolled solutions, you get
        the <a href="#Json">short, super-simple parser definition</a>, and
        excellent error free error reporting. While for super-high-performance
        use cases you may still want a hand-rolled parser, for many ad-hoc
        situations a FastParse parser would do just fine.
</p>
    <p>
        A similar speed ratio can be seen in parsing a
        <a href="https://github.com/scala-js/scala-js/blob/master/compiler/src/main/scala/org/scalajs/core/compiler/GenJSCode.scala">sample Scala file</a>
        comparing FastParse andScalac's inbuilt hand-written Scala-language parser:
</p>
    <table style="width: 100%;" class="pure-table">
        <thead>
            <th>Benchmark</th><th>Score</th></thead>
        <tbody>
            <tr>
                <td>fastparse</td><td>203</td></tr>
            <tr>
                <td>scalac</td><td>754</td>
</tr></tbody></table>
    <p>
        Or comparing Fastparse's Python parser with the Jython Python parser:
</p>
    <table style="width: 100%;" class="pure-table">
        <thead>
            <th>Benchmark</th><th>Score</th></thead>
        <tbody>
            <tr>
                <td>fastparse</td><td>406</td></tr>
            <tr>
                <td>jython</td><td>472</td></tr></tbody></table>
    <p>
        In all these cases, you can see that the iterations-per-second
        performance of Fastparse parsers is comparable to various production
        quality parsers. While the Fastparse parser may be a few times slower,
        it is nonetheless competitive, and at the same time is usually less
        than 1/10th as much code to write, understand and debug.
</p>
    <h1 id="ImprovingPerformance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ImprovingPerformance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Improving Performance</h1>

        <p>
            There are many ways to improve performance of your FastParse parsers.
            If you study the example parsers included in the repo, those already
            have many of these techniques applied, and if you follow the same style
            you'll probably do ok. Nevertheless, here are some concrete tips:
</p>
        <ul>
            <li>
                <b>Understand your Parser's behavior</b>: using <a href="#Log">Log</a>, or
                by <code>Instrumenting Parsers</code>. Often poor performance is due
                to parsers doing the wrong thing: attempting more alternatives
                than they need to, or backtracking and repeating the same
                parse many times. Understanding the flow of how your parser works
                is the first step in identifying these issues and fixing them
</li>
            <li>
                <b>Avoid Backtracking</b>: FastParse parsers have unlimited backtracking,
                which is convenient for getting something working initially, but
                inconvenient when you want things to be fast. If you have a parser
                with lots of backtracking, see if you can factor out parts of it
                so they only get parsed once, e.g. turning <code>a ~ b | a ~ c</code> into
                <code>a ~ (b | c)</code>
</li>
            <li>
                <b>Use <a href="#Cuts">Cuts</a></b>: although you can remove backtracking manually,
                it is easy to make a mistake and miss some of it, or for backtracking
                to creep back in as you make further changes to your parser. Cuts
                prevent that, ensuring that your parser never backtracks past certain
                points no matter what.
</li>
            <li>
                <b>Use <a href="#Utilities">Utilities</a></b>: things like <a href="#CharPred">CharPred</a>,
                <a href="#CharIn">CharIn</a>, <a href="#CharsWhile">CharsWhile</a>, <a href="#StringIn">StringIn</a>,
                <a href="#CharsWhileIn">CharsWhileIn</a> are orders of magnitude faster than
                implementing their behavior yourself with <code>|</code> and <code>.rep</code>.
                Use them where-ever possible
</li></ul>
    <h1 id="Profiling" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Profiling" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Profiling</h1>
        <p>
            Since FastParse Parsers are just methods, you can use standard
            profiling techniques to show where in the parser time is being
            spent. For example, here is the <a href="https://www.ej-technologies.com/products/jprofiler/overview.html">JProfiler</a>
            profile of the <a href="#ScalaParse">ScalaParse</a> Scala syntax parser:
</p>
        <img style="width: 100%;" src="JProfiler.png" />

        <p>
            Using standard tools, you can easily dig into what parts of your
            parser are slow and why</p>

    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="DebuggingParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Debugging Parsers<a class=" scalatex-site-Styles-headerLink" href="#DebuggingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        The vast majority of your time working with FastParse, your parsers
        will be incorrect. This is almost by definition, because once your
        parser is correct, you'll be done and can go do something else with
        your life!
</p>
    <p>
        Even if your parsers are correct, often you'll find
        yourself parsing broken input:</p>
    <ul>
        <li>
            Perhaps a user typed in mal-formed code for your custom programming-language?</li>
        <li>
            Or someone corrupted your data files?</li>
        <li>
            Or some external service isn't properly following your
            protocol spec?
</li></ul>
    <p>
        No matter what goes wrong, <i>someone</i> will need to figure
        it out and fix it. Thus FastParse puts a lot of effort
        into making working with broken parsers and input as easy as possible.
</p>
    <p>
        Let's take an example Parser:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{

  def plus[$: P] = P( &quot;+&quot; )
  def num[$: P] = P( CharIn(&quot;0-9&quot;).rep(1) ).!.map(_.toInt)
  def side[$: P] = P( &quot;(&quot; ~ expr ~ &quot;)&quot; | num )
  def expr[$: P]: P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L440-L448" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        This is a simple parser that parses some basic arithmetic expressions:
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1+2</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(1+2)+(3+4)</code>, etc. It's simpler than
        <a href="#Math">Math</a> parser shown at the top of the page, as it does not handle
        multiple operators in a row e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1+2+3+4</code>, nor does it handle
        operator precedence. Nevertheless it will be enough to show how error
        handling and debugging works.
</p>
    <p>
        If we run the parser on a bad input, though, we get this:

</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">parse(&quot;(1+(2+3x))+4&quot;, Foo.expr(_)),
&quot;&quot;&quot;Parsed.Failure(Position 1:1, found &quot;(1+(2+3x))&quot;)&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L449-L451" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        As you can see, the error message is pretty generic: &quot;i had a syntax
        error at line 1 column 1 (index 0)&quot;. Why does it tell us that?
</p>
    <h1 id="UsingCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using Cuts</h1>
        <p>
            The answer is that as far as FastParse knows, you could have wanted
            either the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> or the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> at
            that position, and it doesn't know which one. Thus even though it
            starts off parsing a paren, when that branch eventually fails (it
            tries to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> at index 7, but finds a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code>)
            it backtracks out of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> parser and
            then tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code>. When that fails, it doesn't
            know which side was &quot;meant&quot; to succeed, and so it gives up and
            just tells you both sides failed to parse.</p>
        <p>
            Although FastParse doesn't know which branch was meant to succeed,
            <i>we</i> know that once we've parsed a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>, it can no
            longer parse a number! Thus there's no point in backtracking and
            trying that side of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code>. We can tell FastParse this
            fact by adding <a href="#Cuts">Cuts</a> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> after <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{

  def plus[$: P] = P( &quot;+&quot; )
  def num[$: P] = P( CharIn(&quot;0-9&quot;).rep(1) ).!.map(_.toInt)
  def side[$: P] = P( &quot;(&quot; ~/ expr ~ &quot;)&quot; | num )
  def expr[$: P]: P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L455-L462" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Now, once FastParse sees a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>, it can no longer
            backtrack! Thus it knows that whatever error occurs later, it
            <i>must</i> be because it failed to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> and not
            because <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> failed. Then the error message becomes much
            more precise and useful:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">parse(&quot;(1+(2+3x))+4&quot;, Foo.expr(_)),
&quot;&quot;&quot;Parsed.Failure(Position 1:8, found &quot;x))+4&quot;)&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L463-L465" target="_blank"><i class="fa fa-link "></i></a></pre>


    <h1 id="UsingLog" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingLog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using Log</h1>
        <p>
            We can add <a href="#Log">Log</a> calls to make FastParse tell us a lot
            more about what a parser is doing. For example, if we want to
            know whenever a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> is being
            attempted, we can add <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> to those to parsers to
            find out:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{

  def plus[$: P] = P( &quot;+&quot; )
  def num[$: P] = P( CharIn(&quot;0-9&quot;).rep(1) ).!.map(_.toInt)
  def side[$: P] = P( &quot;(&quot; ~/ expr ~ &quot;)&quot; | num ).log
  def expr[$: P]: P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}.log
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L492-L501" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Note that <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> by default prints out the name of the
            enclosing parser method. This is what you want if you are logging
            the body of an entire method like <code>DeepFailure</code> or <code>Foo</code>,
            but if you want to log the individual bits and pieces like
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;A&quot;</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;B&quot;</code> you'll need to pass in the name
            of the thing you are logging manually (as we have done here)</p>
        <p>
            Then when you run it on an invalid input:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">parse(&quot;(1+(2+3x))+4&quot;, Foo.expr(_))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L501-L502" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            You get a dump of everything the logged parsers are trying to do
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">&quot;&quot;&quot;+Foo:1:1, cut
  |  +DeepFailure:1:1
  |  -DeepFailure:1:1:Failure(DeepFailure:1:1 / &quot;C&quot;:1:1 ...&quot;AB&quot;)
  |-Foo:1:1:Success(1:3, cut)
  |</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L480-L485" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">+</code> is when a parser is started, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">-</code> is when it
            finishes with either a success or a failure. In the case of failure,
            it tells you what the stack was when it failed.</p>
        <p>
            The general strategy for adding <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code>s is:
</p>
        <ol>
            <li>
                Is my parser misbehaving? This is usually obvious from seeing
                parse failures when there shouldn't be</li>
            <li>
                Are any sub-parsers which I believe should be succeeding/failing/getting-called, aren't? Add logging to the sub-parsers. You can do this at the definition-site of the sub-parsers as shown above, or to the use-site e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side.log(&quot;SIDE 1&quot;) ~ plus ~ side.log(&quot;SIDE 2&quot;)</code> if the parser is used in multiple places and you only want to log this usage.</li>
            <li>
                Look at the logging, see some parser behaving strangely. Go to 1.
</li></ol>
        <p>
            In general, you do not want to add too many <code>.log()</code> calls
            otherwise the output becomes noisy and verbose and hard to
            understand. Adding them incrementally helps you narrow down the
            problem while still keeping the output readable.
</p>
    <h1 id="Tracing" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tracing" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tracing</h1>
        <p>
            By default, on failure, FastParse only provides the index and the
            last parser which failed at that index. This is information
            FastParse already has and is thus cheap to provide, and often is
            enough to show what went wrong, and where.</p>
        <p>
            Often you want something more, though, and for that FastParse
            provides tracing, as described in the documentation of
            <a href="#ParsingResults">Parsing Results</a>. By computing the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traced</code>
            value on a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code>, FastParse will perform a whole
            second parse on the original input, starting from the same index,
            but with additional tracing code to keep track of what's
            happening. This typically costs ~2x as much as the original parse,
            so isn't done by default, but it's trivial to ask for it.</p>
        <p>
            For example, this is tracing being done on an invalid input we know
            will fail:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Failure(stack, idx, extra) = parse(&quot;(1+(2+3x))+4&quot;, Foo.expr(_))</code></pre>
        <p>
            We know that this input will fail, because our grammar (defined
            earlier) does not contain an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code> in it! It only handles
            numbers and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;+&quot;</code> and parentheses. <code>expected</code> gives us
            the parser that it needed in order to continue (with a readable
            <code>.toString</code>) and <code>idx</code> the index that it failed at:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; (idx, expected) // Last index and last parser at which it failed
(&quot;)&quot;, 7)</code></pre>
        <p>
            But there is also the <code>extra</code> result which contains additional information you can use, e.g. the <code>extra.traced</code> result.
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; extra.traced.trace // The named parsers in the stack when it failed
Expected expr:1:1 / side:1:1 / expr:1:2 / side:1:4 / ([0-9] | &quot;)&quot;):1:8, found &quot;x))+4&quot;

&gt; extra.traced.stack // Same as .trace, but as a List[Frame] rather than String
List(
    (([0-9] | &quot;)&quot;), 7),
    (side, 3),
    (expr, 1),
    (side, 0),
    (expr, 0)
)
</code></pre>
        <p>
            As you can see, tracing gives us a much more detailed view: every
            parser in the stack when the parse failed, what indices they were
            tried at. Apart from getting it as a readable string via
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.trace</code>, you can also get it as structured data via
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.stack</code> in case you want to manipulate it programmatically.

</p>
    <h1 id="InstrumentingParsers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#InstrumentingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Instrumenting Parsers</h1>
        <p>
            FastParse provides an <code>instrument</code> argument, which you can
            use to inject callbacks that let you run code before or after
            every named parse (defined inside a <code>P</code>) is called. This can
            be used for a wide variety of things. For example, you could use it
            to count how many times each parser in the example <a href="#Math">Math</a>
            parser gets called when you parse a simple arithmetic expression:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val callCount = mutable.Map.empty[String, Int]


val instrument = new Instrument {
  def beforeParse(parser: String, index: Int): Unit = {
    callCount(parser) = callCount.getOrElse(parser, 0) + 1
  }
  def afterParse(parser: String, index: Int, success: Boolean): Unit = ()
}

parse(&quot;((1+1*2)+(3*4*5))/3&quot;, expr(_), instrument = instrument)

val expectedCallCount = Map(
  &quot;expr&quot; -&gt; 1,
  &quot;addSub&quot; -&gt; 4,
  &quot;divMul&quot; -&gt; 6,
  &quot;factor&quot; -&gt; 10,
  &quot;number&quot; -&gt; 10,
  &quot;parens&quot; -&gt; 3
)
assert(callCount == expectedCallCount)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L93-L114" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            This is useful for ad-hoc investigation of what your parser is doing:
            you can easily count how many times various parsers are being run,
            whether they're succeeding and failing and at what indices.</p>
        <p>
            The above example runs code <i>before</i> each named <code>P(...)</code>
            parser is run. You can also run code <i>after</i> the parser is
            run:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val resultCount = mutable.Map.empty[(String, Boolean), Int]
val instrument = new Instrument {
  def beforeParse(parser: String, index: Int): Unit = ()
  def afterParse(parser: String, index: Int, success: Boolean): Unit = {
    val resultKey = (parser, success)
    resultCount(resultKey) = resultCount.getOrElse(resultKey, 0) + 1
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L116-L125" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            In this case, we are using it to count not just how many times each
            named <code>P(...)</code> parser is run, but also how many times it
            succeeds and fails. We can parse a &quot;good&quot; input and see that
            most of the attempts by named parser succeed:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Good Parse
parse(&quot;((1+1*2)+(3*4*5))/3&quot;, expr(_), instrument = instrument)

val expectedResultCount = Map(
  (&quot;expr&quot;, true) -&gt; 1,
  (&quot;addSub&quot;, true) -&gt; 4,
  (&quot;divMul&quot;, true) -&gt; 6,
  (&quot;factor&quot;, true) -&gt; 10,
  (&quot;number&quot;, true) -&gt; 7,
  (&quot;number&quot;, false) -&gt; 3,
  (&quot;parens&quot;, true) -&gt; 3
)
assert(resultCount == expectedResultCount)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L125-L139" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            And we can parse invalid input, and see that it results in many of
            the named parsers failing repeatedly in the course of the parse:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Bad Parse
resultCount.clear()
parse(&quot;((1+1*2)+(3*4*))/3&quot;, expr(_), instrument = instrument)

val expectedResultCount2 = Map(
  (&quot;expr&quot;, false) -&gt; 1,

  (&quot;addSub&quot;, true) -&gt; 1,
  (&quot;addSub&quot;, false) -&gt; 3,

  (&quot;divMul&quot;, true) -&gt; 3,
  (&quot;divMul&quot;, false) -&gt; 3,

  (&quot;factor&quot;, true) -&gt; 6,
  (&quot;factor&quot;, false) -&gt; 3,

  (&quot;number&quot;, true) -&gt; 5,
  (&quot;number&quot;, false) -&gt; 4,

  (&quot;parens&quot;, true) -&gt; 1,
  (&quot;parens&quot;, false) -&gt; 3
)
assert(resultCount == expectedResultCount2)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/MathTests.scala#L139-L162" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Which is what you would expect, since the parse overall failed!
            This measurement of pass/fail rates for each parser is a useful
            tool for understanding how the overall parser behaves at runtime:
            which individual parsers are being used over and over and are worth
            optimizing, and which are called only a handful of times and not
            bothering with. If an individual parser is being called over and
            over, you could optimize its internals to make it faster, or you
            could try to refactor the rest of the overall parser so this
            individual parser gets called fewer times.
</p>
        <p>
            Instrumenting parsers typically isn't something you want to
            use on a &quot;production&quot; parser.
            Nevertheless, <code>instrument</code> it is still a useful tool to
            have available in your toolbox if you are unsure of what a
            parser is doing, and can be used to give you insight into
            the runtime behavior of your parsers which is hard to get
            otherwise.
</p>
    <h1 id="UseCases" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UseCases" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Use Cases</h1>
        <p>
            What's the purpose of all this detailed error reporting? The goal
            is three-fold:</p>
        <ul>
            <li>
                You will want to know why parsers as misbehaving while you're
                writing them so you can fix bugs. Often <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traced.trace</code>
                is enough, but you can dig in more deeply if you wish to.</li>
            <li>
                You can use the detailed error traces to your users when they
                enter invalid input. For example, instead of just
                <i>&quot;Syntax error at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">7</code>&quot;</i> You can say
                <i>&quot;Syntax error at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">7</code>, expected
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">[0-9] | &quot;)&quot;</code>, while trying to parse a
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">3</code>, while trying to parse an
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1</code>, ...&quot;</i>. Naturally, you do
                not need to overwhelm the user with debug information, but now
                you have the power to reveal as much or as little as you want.
</li>
            <li>
                You can customize the experience of your users when they enter
                invalid input, for example discarding portions of the error
                stack you find not useful for debugging, and formatting the
                remaining parts in a way that your users can best understand.</li></ul>
        <p>
            In general, FastParse's error reporting is detailed and structured.
            As a <i>developer</i>, most of your time spent interacting with your
            parser is when it is incorrect and throwing errors at you. As a
            <i>user</i>, most of your time spent interacting with the parser is
            when your input is incorrect and it is throwing errors at you. This
            is almost self-evident, since once your parser is correct or your
            input is correct you're done and go do other things</p>
        <p>
            Thus, FastParse makes an effort to make the error reporting both
            detailed and structured. This means as a developer you can quickly
            diagnose problems, and (if you wish to) put in effort to use the
            structured errors to help <i>your users</i> diagnose problems. That
            makes life better for everybody.</p>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Comparisons" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Comparisons<a class=" scalatex-site-Styles-headerLink" href="#Comparisons" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        FastParse differs from all other parser-combinator libraries in the
        Scala universe, in quite substantial ways:
</p>
    <ul>
        <li>
            Compared to <a href="https://github.com/sirthias/parboiled2">Parboiled2</a>,
            FastParse has much better error messages (both compile and run-time),
            has much simpler and more predictable behavior. Parboiled2 suffers from many
            <a href="https://groups.google.com/forum/#!msg/scala-internals/4N-uK5YOtKI/9vAdsH1VhqAJ">usability problems and bugs</a>
            that make it excruciating difficult to use, and also does not
            support higher-order rules. FastParse suffers from none of these
            problems.</li>
        <li>
            <a href="https://github.com/sirthias/parboiled/wiki">Parboiled1</a>
            is a Java library, and does not/cannot work on Scala.js</li>
        <li>
            <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a>
            is similar, but poorly executed. It is ~2-300x slower than FastParse,
            has an awkward inheritance-based API, and is full of bugs despite
            being half a decade old. FastParse is faster, has self-contained
            pure-functional parsers, and fixes bugs e.g. by having the
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> operator actually work.</li></ul>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Internals" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Internals<a class=" scalatex-site-Styles-headerLink" href="#Internals" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        FastParse is implemented as a set of methods that perform a
        recursive-descent parse on the given input, with all book-keeping
        information maintained in the <code>fastparse.ParsingRun[T]</code> objects
        (abbreviated <code>fastparse.P[T]</code>). <code>ParsingRun</code>s are mutable,
        heavily stateful objects that keep track of everything related to the
        parse: the current index, whether backtracking is allowed, any value we
        may want to return, etc.. By defining your parsers as:
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">def myParser[_: P]: P[T] = P( ... )
</code></pre>
    <p>
        We ensure that a <code>ParsingRun</code> object is required to start the
        parse, the same instance is made available implicitly to any other
        parsers <code>myParser</code> may call and finally returned with the relevant
        value of type <code>T</code> stored in it.
</p>
    <h1 id="Inlining" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Inlining" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Inlining</h1>

        <p>
            FastParse heavily relies on inlining to achieve performance; many
            of the FastParse operators such as <code>a ~ b</code>, <code>!a</code>,
            <code>a.rep</code> etc. are implemented using macros which inline their
            implementation code at the call-site.</p>
        <p>
            This inlining should be mostly transparent to you, as the operators
            would parse the same input and return the same values as if they
            were not inlined. The only thing you may notice is these operators
            do not appear in stack traces or profiles, as their code is inlined
            as part of the enclosing method (e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def myParser</code>).
</p>
    <h1 id="Opacity" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Opacity" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Opacity</h1>
        <p>
            Fastparse parsers are opaque: as plain methods
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def myParser[_: P]: P[T]</code>, the only thing you can do is
            invoke them. You cannot programmatically inspect the body of a
            parser, see what other parsers it depends on, or perform any
            transformations on it. This in turn allows us to perform additional
            optimizations to improve performance of the parsing run.
</p>
    <h1 id="Synchronous" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Synchronous" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Synchronous</h1>
        <p>
            As plain methods, Fastparse parsers are synchrous: calling a parser
            method does not return  until the parse is complete. Even if
            parsing streaming input, FastParse will block
            on the input iterator until it either provides the text to parse
            or is exhausted.
</p>
    <h1 id="Stack-Limited" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Stack-Limited" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Stack-Limited</h1>
        <p>
            FastParse's parsing methods use the normal JVM method-call-stack
            to perform their recursive descent. This means that excessively
            deep or nested parses can cause a stack-overflow, which can be
            mitigated by the normal JVM flags to increase the stack size in
            memory.</p>

    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ErrorReportingInternals" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Error Reporting Internals<a class=" scalatex-site-Styles-headerLink" href="#ErrorReportingInternals" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        This section goes into detail of how the FastParse error reporting
        algorithm works. In general, it should &quot;just work&quot; when you call
        <code>.longMsg</code>, <code>.longAggregateMsg</code>, or <code>.longTerminalsMsg</code>.
        Nevertheless, it is both complicated as well important enough that it
        is worth documenting in detail
</p>
    <p>
        The two levels of error reporting that are most interesting are
        <code>.longAggregateMsg</code> and <code>.longTerminalsMsg</code>. Consider a failed
        parse of an example simplified arithmetic parser:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse._, NoWhitespace._
def num[$: P] = P(CharIn(&quot;0-9&quot;)).log
def sum[$: P] = P(&quot;(&quot; ~/ expr ~ &quot;+&quot; ~/ expr ~ &quot;)&quot;).log
def expr[$: P]: P[_] = P(num | sum).log

val Parsed.Failure(_, _, extra) = fastparse.parse(&quot;(1+?)&quot;, expr(_))
val trace = extra.trace()
val longTerminalsMsg = trace.longTerminalsMsg
assert(
  longTerminalsMsg ==
    &quot;&quot;&quot;Expected expr:1:1 / sum:1:1 / expr:1:4 / ([0-9] | &quot;(&quot;):1:4, found &quot;?)&quot;&quot;&quot;&quot;
)
assert(
  trace.longAggregateMsg ==
    &quot;&quot;&quot;Expected expr:1:1 / sum:1:1 / expr:1:4 / (num | sum):1:4, found &quot;?)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/test/src/fastparse/ExampleTests.scala#L558-L575" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        This fails on the <code>?</code> being invalid syntax. The following error reporting
        levels will treat this as follows:</p>
    <ul>
        <li>
          <code>terminalMsgs</code> lists all the lowest-level terminal parsers which are
          tried at the given <code>traceIndex</code>, i.e. the character class <code>[0-9]</code> and the
          token <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>. This is useful to answer the question &quot;what token/char can I
          put at the error position to make my parse continue&quot;. The implementation
          of <code>terminalMsgs</code> is straightforward: we simply call
          <code>reportTerminalMsg</code> in every terminal parser, which collects all the
          messages in a big list and returns it.</li>
        <li>
          <code>aggregateMsgs</code> lists all high-level parsers which are tried at the given
          <code>traceIndex</code>, i.e. the named parsers <code>num</code> and <code>plus</code>. This is useful to
          answer the question &quot;What construct was the parser trying to do when it
          failed&quot;</li></ul>
    <p>
        The implementation of <code>aggregateMsgs</code> is more interesting, since we need
        to define what &quot;high level&quot; parsers means, which is non-obvious.
</p>
    <h1 id="DefinitionofaggregateMsgs" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#DefinitionofaggregateMsgs" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Definition of aggregateMsgs</h1>
        <p>
            Fastparse uses the following definition for <code>aggregateMsgs</code>:</p>
        <ul>
            <li>
             <code>aggregateMsgs</code> should contain the parsers highest in the call stack,
              whose failure isn't immediately fatal to the parse (due to them being in
              <code>|</code>, <code>.rep</code>, <code>?</code>, or other &quot;backtrackable&quot; operators, but
              not past a <code>cut</code>)</li></ul>
        <p>
            This is a useful definition because we already have the <code>failureStack</code>
            containing all (named) parsers whose failure *is* immediately fatal to the
            parse, both those at <code>traceIndex</code> and those earlier in the input. Thus
            there is no need to duplicate showing any of them in the <code>aggregateMsgs</code>,
            and we can instead go &quot;one level deeper&quot; to find the highest-level parsers
            within the deepest parser of the <code>failureStack</code> and show those instead.
            Thus, in the combined <code>longAggregateMsg</code>, the failure stack shows us
            exactly which parsers failing directly contributed to the failure at
            <code>traceIndex</code>, while the longAggregateMsg tells us what are the
            highest-level parsers FastParse was trying to parse at <code>traceIndex</code> before
            it finally failed.</p>
    <h1 id="ImplementationofaggregateMsgs" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ImplementationofaggregateMsgs" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Implementation of aggregateMsgs</h1>
        <p>
            To collect the <code>aggregateMsgs</code>, We use the following algorithm:</p>
        <ul>
            <li>
              When a parse which started at the given <code>traceIndex</code> fails without a cut:
              Over-write <code>aggregateMsgs</code> with it's <code>shortMsg</code>
</li>
            <li>
                Otherwise:

                <ul>
                    <li>
                        If we are a terminal parser, we set our <code>aggregateMsgs</code> to Nil</li>
                    <li>
                        If we are a compound parser, we simply sum up the <code>aggregateMsgs</code>
                        of all our constituent parts</li></ul></li></ul>
        <p>
            As mentioned earlier, the point of this is to provide the highest-level parsers which
            failed at the <code>traceIndex</code>, but are not already part of the <code>failureStack</code>.
            non-highest-level parsers do successfully write their message to
            <code>aggregateMsgs</code>, but they are subsequently over-written by the higher
            level parsers, until it reaches the point where <code>cut == true</code>, indicating
            that any further higher-level parsers will be in <code>failureStack</code> and using
            their message to stomp over the existing parse-failure-messages in
            <code>aggregateMsgs</code> would be wasteful.</p>
    <h1 id="EdgeCases" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#EdgeCases" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Edge Cases</h1>
        <p>
            These is an edge case where there is no given failure that occurs exactly at
            <code>traceIndex</code> e.g.</p>
        <ul>
            <li>
                Parsing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;ax&quot;</code> with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">P( (&quot;a&quot; ~ &quot;b&quot;) ~ &quot;c&quot; | &quot;a&quot; ~/ &quot;d&quot; )</code></li>
            <li>
                The final failure <code>index</code> and thus <code>traceIndex</code> is at offset 1</li>
            <li>
                We would like to receive the aggregation <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(&quot;b&quot; | &quot;d&quot;)</code></li>
            <li>
                But <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(&quot;a&quot; ~ &quot;b&quot;)</code> passes from offsets 0-2, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;c&quot;</code> fails

</li></ul>
        <p>
            In such a case, we truncate the <code>shortMsg</code> at
            <code>traceIndex</code> to only include the portion we're interested in (which directly
            follows the failure). This then gets aggregated nicely to form the error
            message from-point-of-failure.</p>
        <p>
            A follow-on edge case is parsing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;ax&quot;</code> with</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">val inner = P( &quot;a&quot; ~ &quot;b&quot; )
P( inner ~ &quot;c&quot; | &quot;a&quot; ~/ &quot;d&quot; )</code></pre>
        <ul>
            <li>
                Here, we find that the <code>inner</code> parser starts before the <code>traceIndex</code> and
                fails at <code>traceIndex</code>,</li>
            <li>
                But we want our aggregation to continue being <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(&quot;b&quot; | &quot;d&quot;)</code>, rather than
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(inner | &quot;d&quot;)</code>.
</li>
            Thus, for opaque compound parsers like <code>inner</code> which do not expose their
            internals, we use <code>forceAggregate</code> to force it to expose it's internals
            when it's range covers the <code>traceIndex</code> but it isn't an exact match</ul>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ChangeLog" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Change Log<a class=" scalatex-site-Styles-headerLink" href="#ChangeLog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

    <h1 id="3.0.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#3.0.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>3.0.0</h1>
        <ul>
            <li>
                Scala 3.x support, starting from 3.2.2 <a href="https://github.com/lihaoyi/fastparse/issues/271">#271</a>.
                All functionality works in Scala 3.0.0, though performance may vary slightly due
                to differences in the implementation.</li>
            <li>
                Make whitespace handling a proper <code>fastparse.Whitespace</code> trait,
                rather than a function type <a href="https://github.com/lihaoyi/fastparse/issues/272">#272</a>,
                to avoid problems with parse failures being silently discarded
                <a href="https://github.com/lihaoyi/fastparse/issues/261">#261</a></li>
            <li>
                Dependency bumps: <code>com.lihaoyi::geny:1.0.0</code>, <code>com.lihaoyi::sourcecode:0.3.0</code></li>
            <li>
                <code>Fail</code> parser now takes an optional message
                <a href="https://github.com/lihaoyi/fastparse/issues/244">#244</a></li>
            <li>
                Significant overhaul of <code>aggregateMsg</code>/<code>longAggregateMsg</code>
                implementation, with code cleanup and bugfixes
                <a href="https://github.com/lihaoyi/fastparse/issues/276">#276</a>.
                A lot of internal-facing method call were modified or renamed, but
                this is not expected to require changes in user code.</li>
            <li>
                Note that this is a binary incompatible change from Fastparse 2.x.
                It is largely source compatible, except for users who are defining
                custom whitespace implementations which would need to replace their
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">implicit val whitespace</code> with
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">implicit object whitespace extends Whitespace</code>

</li></ul>
    <h1 id="2.3.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.3.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.3.1</h1>
        <ul>
            <li>
                Support for Scala-Native 0.4.0</li></ul>
    <h1 id="2.2.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.2.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.2.2</h1>
        <ul>
            <li>
                You can now call <code>fastparse.parse</code> on any
                <a href="https://github.com/lihaoyi/geny#readable">geny.Readable</a> value,
                such as <code>Array[Byte]</code>s to parse binary data, or <code>java.io.InputStream</code>s
                for streaming parsing
</li></ul>
    <h1 id="2.2.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.2.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.2.0</h1>
        <ul>
            <li>
                <code>fastparse.Parsed.Failure</code> is no longer a case class, to improve
                the pprinting in a the Ammonite REPL</li></ul>
    <h1 id="2.1.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.1.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.1.3</h1>
        <ul>
            <li>
                Support for Scala 2.13.0</li></ul>
    <h1 id="2.1.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.1.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.1.0</h1>
        <ul>
            <li>
                Reverted the failure-tracing behavior of <code>trace.aggregateMsg</code>
                back to it's behavior in Fastparse 1.x (i.e. showing the high-level
                parsers that failed, rather than the low-level terminals). The
                previous Fastparse 2.0.5 behavior of showing the failed terminals
                is now available separately under <code>trace.terminalsMsg</code></li>
            <li>
                Fix crash when streaming parsing whitespace grammars (
                <a href="https://github.com/lihaoyi/fastparse/issues/208">#208</a>)</li></ul>
    <h1 id="2.0.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.0.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.0.5</h1>
        <ul>
            <li>
                Remove unnecessary runtime scala-reflect dependency when parsing
                non-literal strings</li></ul>
    <h1 id="2.0.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#2.0.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>2.0.4</h1>
        <ul>
            <li>
                Major rewrite of <a href="#Internals">Internals</a> with some changes to
                user-facing interface; binary and source incompatible with
                <a href="#1.0.0">1.0.0</a></li>
            <li>
                3-4x performance improvements on most benchmarks</li>
            <li>
                Parsers are no longer immutable objects, but just methods taking
                and returning <code>fastparse.ParsingRun</code> instances</li>
            <li>
                Much better support for <a href="#Profiling">Profiling</a> your parsers</li>
            <li>
                Parsers now need to be defined as
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def myParser[_: P] = P(...)</code>, rather than
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val myParser = P(...)</code></li>
            <li>
                <a href="#WhitespaceHandling">Whitespace Handling</a> management has been overhauled; you now
                import or define a whitespace implicit (e.g.
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import NoWhitespace._</code>) rather than defining a
                <code>WhitespaceApi</code> instance to import extension methods from.</li>
            <li>
                Dropped support for Byte Parsers (due to low uptake), Scala 2.10,
                Scala-Native (until 0.4.0 is out)</li>
            <li>
                <code>.flatMap</code> now consumes whitespace between the first and
                second parsers; use <code>.flatMapX</code> if you want to avoid this.</li></ul>
    <h1 id="1.0.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#1.0.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>1.0.0</h1>
        <ul>
           <li>
                Published <code>fastparse-byte</code> for Scala Native.</li></ul>
    <h1 id="0.4.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.4</h1>
        <ul>
            <li>
                Scala Native support for the modules: <code>fastparse</code>,
                <code>scalaparse</code>, <code>pythonparse</code> and <code>cssparse</code>.
                Porting to Scala Native required no diffs in the source code,
                only build modifications. This release should be identical to
                0.4.3.
</li></ul>
    <h1 id="0.4.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.3</h1>
        <ul>
            <li>
                Added documentation on <a href="#ImprovingPerformance">Improving Performance</a> and
                <code>Startup Performance</code>, along with many micro-optimizations
                and additional tools (below) for improving startup performance. Using these
                tools &amp; techniques, you can expect about a 10x reduction in time
                taken to initialize your FastParse parsers. This is particularly
                relevant for using FastParse in interactive websites via Scala.js.
</li>
            <li>
                Added <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.CharPredicates</code>, which provides faster
                versions of methods like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.isDigit</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.isUpper</code>
                which tend to be slow on Scala.js
</li>
            <li>
                Added a <a href="#CharsWhileIn">CharsWhileIn</a> (and the corresponding <code>BytesWhileIn</code>)
                operator: a hybrid between <a href="#CharsWhile">CharsWhile</a> and <a href="#CharIn">CharIn</a>.
                This should make it more convenient to continually consume characters
                within a certain set.
</li>
            <li>
                Added <code>CharsWhile.raw</code>, <code>CharPred.raw</code>
                intrinsics, which are identical to the non-<code>raw</code> versions except
                these do not pre-compute a lookup table for use during parsing. This
                could be useful if you find your parsers are taking too long to
                initialize and don't mind sacrificing a bit of steady-state
                performance.
</li>
            <li>
                Trailing comma support for ScalaParse, thanks to
                <a href="https://github.com/dwijnand">Dale Wjinand</a>
</li>
            <li>
                Removed unnecessary runtime dependency from CssParse on
                <code>net.sourceforge.cssparser</code>, since we were only using it
                in tests, thanks to <a href="https://github.com/ritschwumm">ritschwumm</a></li>
            <li>
                Tightening up Scalaparse: added some cuts to improve the error
                positioning after semicolons within for-comprehensions,
                reduced the number of places postfix expressions were allowed by our
                parser to better reflect the actual Scala grammar
</li></ul>
    <h1 id="0.4.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.2</h1>
        <ul>
            <li>
                Cross-publish for Scala 2.12.x</li></ul>
    <h1 id="0.4.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.1</h1>
        <ul>
            <li>
                Fix off-by-one error in generation of <code>line:col</code> indices
                in error traces for string parsing</li>
            <li>
                Make <code>.log()</code> use the same <code>line:col</code> indices during
                string-parsing that error traces do, for consistency</li>
            <li>
                Optimize <code>line:col</code> message generation to avoid
                unnecessary allocations and copying.
</li></ul>
    <h1 id="0.4.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.0</h1>
        <ul>
            <li>
                New <a href="#CssParse">CssParse</a> in cssparse module, as an example CSS parser
                written using FastParse.
</li>
            <li>
                FastParse now supports <code>Byte Parsers</code>! You can parse
                binary data using FastParse, using all the same operators and
                combinators you may already be familiar with
</li>
            <li>
                New <code>MidiParse</code>, <code>BmpParser</code> and
                <code>ClassParser</code> example parsers, as working examples of
                how Fastparse's new <code>Byte Parsers</code> are written.
</li>
            <li>
                Support for <a href="#StreamingParsing">Streaming Parsing</a>
</li>
            <li>
                Many internal refactors in order to support the new
                <code>Byte Parsers</code> and <a href="#StreamingParsing">Streaming Parsing</a>.
                <code>Parser</code> and <code>ParserApi</code> are now
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">abstract class</code>es instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">trait</code>s, and
                take implicits that are necessary for them to operate.
</li>
            <li>
                Many of the original types have been moved from the
                <code>fastparse</code> package into <code>fastparse.core</code>, and have
                grown additional type-parameters and implicits. If you
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all._</code> or
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.byte.all._</code>, that should include
                aliases for most of the useful objects and types with the
                relevant type-parameters set to the correct values, and bring
                in the necessary implicits for things to work.
</li>
            <li>
                The old <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def wspStr(s: String): P0</code> implicit has been
                renamed <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def LiteralStr(s: String): P0</code>; the old name was a
                copy-paste from scala-parser-combinators, and never made much
                sense anyway
</li>
            <li>
                code{Unapply} method to allow pattern matching on parsers,
                thanks to <a href="https://github.com/volth">volth</a>.
</li>
            <li>
                Added a <code>StringInIgnoreCase</code> parser to allow matching
                on multiple strings like <a href="#StringIn">StringIn</a> but case-insensitively,
                thanks to <a href="https://github.com/jimdickinson">Jim Dickinson</a>.
</li></ul>
    <h1 id="0.3.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.7</h1>
        <ul>
            <li>
                Bump version of <code>sourcecode</code> from <code>0.1.0</code> to <code>0.1.1</code></li></ul>
    <h1 id="0.3.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.6</h1>
        <ul>
            <li>
                Fix <b>#77</b>: deduplicate traceParsers in WhitespaceAPI to prevent stack overflow, by <a href="https://github.com/jeroenr">Jeroen Rosenberg</a></li></ul>
    <h1 id="0.3.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.5</h1>
        <ul>
            <li>
                Minor improvements to error-reporting in Scalaparse; error messages inside tuple-types and refinement-types should be slightly more precise</li></ul>
    <h1 id="0.3.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.4</h1>
        <ul>
            <li>
                Fix <b>#69</b>: performance problem in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">StringsIn</code> parser, which resulted in initialization time exponential relative to the length of the longest string, by <a href="https://github.com/rklaehn">Rudiger Klaehn</a></li></ul>
    <h1 id="0.3.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.3</h1>
        <ul>
            <li>
                <b>#66</b> Bugfix: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.rep</code> now handles max=0 properly, by <a href="https://github.com/ProjectZetta/">Martin Senne</a>
</li>
            <li>
                Further restructuring of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Result</code> by <a href="https://github.com/ProjectZetta/">Martin Senne</a>
                 <ul>
                     <li>
                         Object <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code> has been renamed to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>
</li>
                     <li>
                         Former <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code> has moved to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>.
</li>
                     <li>
                         Methods for position retrieval <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">line</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">col</code> have moved to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure.Extra</code>
</li></ul></li>
            <li>
                <b>#59</b> Fix <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.core.Result.Failure.formatParser()</code> throwing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">UnsupportedOperationException</code> on receiving an empty string as an input, by <a href="https://github.com/solar">solar</a></li>
            <li>
                <b>#61</b> Added the <a href="#Opaque">Opaque</a> combinator, which allows to provide more high-level error messages, by <a href="https://github.com/stanch">Nick Stanch</a></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure</code> has been restructured: Less-commonly-used properties like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">input</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">traced</code> have been aggregated into an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure.Extra</code> object, simplifying pattern matching. By <a href="https://github.com/ProjectZetta/">Martin Senne</a>
</li></ul>
    <h1 id="0.3.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.2</h1>
        <ul>
            <li>
                Slightly better parsing of triple-quote strings in Scalaparse</li>
            <li>
                Added an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">type Result[T]</code> to match the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val Result</code> inside <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.all</code></li></ul>
    <h1 id="0.3.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.1</h1>
        <ul>
            <li>
                <b>#47</b> Upgraded to Scala.js 0.6.5, removed unnecessary <code>CharPredicate</code>s</li>
            <li>
                <b>#42</b> Renamed <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~! b</code> to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~/ b</code> to avoid confusion with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~ !b</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code> objects now expose the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.line</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.col</code> attributes, in addition to the raw <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.index</code>, and display these in the default trace messages</li>
            <li>
                <b>#27</b> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> now can take a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">max</code> in addition to a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">min</code></li>
            <li>
                <b>#40</b> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> now properly displays the proper snippet of text when propagating failure upward</li></ul>
    <h1 id="0.2.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.1</h1>
        <ul>
            <li>
                Simplified ScalaParse internals slightly</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser#get</code> now throws a custom <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">SyntaxError</code> with relevant metadata, instead of a plain <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Exception</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WhitespaceApi</code>'s <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WL</code> value no longer leaks out when you import from it</li></ul>
    <h1 id="0.2.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.0</h1>
        <ul>
            <li>
                Default import changed from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse._</code> to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all._</code>, to make space for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi._</code></li>
            <li>
                Major changes to parser internals: the internal representation of parse results in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Mutable.{Success, Failure}</code> has been split off from the immutable external represenation <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.{Success, Failure}</code></li>
            <li>
                Error-reporting has been overhauled, and is greatly improved at the cost of being more expensive. Detailed errors now require a second parse with instrumentation</li>
            <li>
                The cheap &amp; spartan error data in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure</code> has been split out from the expensive but detailed error traces in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure#traced</code>.</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> now uses the parser's own <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.toString</code> by default if you don't pass in a tag, for convenience.</li>
            <li>
                Added the ability to exclude the default parser operators via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi._</code>, allowing you to import custom sets of operators tailored to your needs.</li>
            <li>
                Introduced the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.WhitespaceApi</code> class, which replaces the default set of operators with a new set which eagerly consumes whitespace between parsers.</li>
            <li>
                Updated ScalaParse to use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.WhitespaceApi</code>, resulting in much more precise error locations. Errors are now positioned before the characters which failed, rather than before the preceding whitespace, and syntax errors in comments now provide better errors</li>
            <li>
                Added unit tests and examples/demos of <a href="#WhitespaceHandling">Whitespace Handling</a> and <a href="#IndentationGrammars">Indentation Grammars</a></li>
            <li>
                Added <a href="#Filter">Filter</a> to the API, to complement <a href="#Map">Map</a> and <a href="#FlatMap">FlatMap</a></li></ul>
    <h1 id="0.1.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.7</h1>
        <ul>
            <li>
                More fixes for ScalaParse, added more projects to test suite</li>
            <li>
                Auto-generate <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Sequencer</code> instances up to 22</li>
            <li>
                Removed unnecessary runtime utest dependency</li></ul>
    <h1 id="0.1.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.6</h1>
        <ul>
            <li>
                Introduced five new projects into the test suite: ScalaIDE, GitBucket, Scalding, Scaloid, Marathon</li>
            <li>
                Fixed bug in ScalaParse around using function <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">=&gt;</code> types as type ascriptions</li>
            <li>
                Added ability to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">instrument</code> parsers, in order to gather out-of-band information about them e.g. for debugging or profiling</li>
            <li>
                Added <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase</code> combinator, for case-insensitive string matching</li>
            <li>
                Cross-published for Scala 2.10</li></ul>

</div>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"FastParse 3.0.0","children":[{"value":"Getting Started","children":[]},{"value":"Writing Parsers","children":[{"value":"Basic","children":[{"value":"Failures","children":[]},{"value":"Sequence","children":[]},{"value":"Repeat","children":[]},{"value":"Optional","children":[]},{"value":"Either","children":[]},{"value":"End, Start","children":[]},{"value":"Pass, Fail","children":[]},{"value":"Index","children":[]},{"value":"Capture","children":[]},{"value":"AnyChar","children":[]},{"value":"Positive Lookahead","children":[]},{"value":"Negative Lookahead","children":[]},{"value":"Map","children":[]},{"value":"FlatMap","children":[]},{"value":"Filter","children":[]},{"value":"Opaque","children":[]},{"value":"Log","children":[]}]},{"value":"Utilities","children":[{"value":"CharPred","children":[]},{"value":"CharIn","children":[]},{"value":"CharsWhile","children":[]},{"value":"CharsWhileIn","children":[]},{"value":"StringIn","children":[]}]},{"value":"Cuts","children":[{"value":"No Cuts","children":[]},{"value":"Cuts","children":[]},{"value":"Rep Cuts","children":[]},{"value":"Isolating Cuts","children":[]}]},{"value":"Higher Order Parsers","children":[]}]},{"value":"Streaming Parsing","children":[{"value":"Streaming Parsing Buffer Size","children":[]},{"value":"Streaming Parsing Performance","children":[]},{"value":"Streaming Parsing Limitations","children":[]}]},{"value":"Example Parsers","children":[{"value":"Math","children":[]},{"value":"Whitespace Handling","children":[]},{"value":"Indentation Grammars","children":[]},{"value":"Json","children":[]},{"value":"ScalaParse","children":[{"value":"Using ScalaParse","children":[]}]},{"value":"PythonParse","children":[]},{"value":"CssParse","children":[]}]},{"value":"API Highlights","children":[{"value":"Parsing Results","children":[]}]},{"value":"Performance","children":[{"value":"Improving Performance","children":[]},{"value":"Profiling","children":[]}]},{"value":"Debugging Parsers","children":[{"value":"Using Cuts","children":[]},{"value":"Using Log","children":[]},{"value":"Tracing","children":[]},{"value":"Instrumenting Parsers","children":[]},{"value":"Use Cases","children":[]}]},{"value":"Comparisons","children":[]},{"value":"Internals","children":[{"value":"Inlining","children":[]},{"value":"Opacity","children":[]},{"value":"Synchronous","children":[]},{"value":"Stack-Limited","children":[]}]},{"value":"Error Reporting Internals","children":[{"value":"Definition of aggregateMsgs","children":[]},{"value":"Implementation of aggregateMsgs","children":[]},{"value":"Edge Cases","children":[]}]},{"value":"Change Log","children":[{"value":"3.0.0","children":[]},{"value":"2.3.1","children":[]},{"value":"2.2.2","children":[]},{"value":"2.2.0","children":[]},{"value":"2.1.3","children":[]},{"value":"2.1.0","children":[]},{"value":"2.0.5","children":[]},{"value":"2.0.4","children":[]},{"value":"1.0.0","children":[]},{"value":"0.4.4","children":[]},{"value":"0.4.3","children":[]},{"value":"0.4.2","children":[]},{"value":"0.4.1","children":[]},{"value":"0.4.0","children":[]},{"value":"0.3.7","children":[]},{"value":"0.3.6","children":[]},{"value":"0.3.5","children":[]},{"value":"0.3.4","children":[]},{"value":"0.3.3","children":[]},{"value":"0.3.2","children":[]},{"value":"0.3.1","children":[]},{"value":"0.2.1","children":[]},{"value":"0.2.0","children":[]},{"value":"0.1.7","children":[]},{"value":"0.1.6","children":[]}]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               